{
  "data": [{
    "title": "2020년 3회 기출문제",
    "question": [{
      "num": 1,
      "subject": 1,
      "ask": "요구사항 분석 시에 필요한 기술로 가장 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "청취과 인터뷰 질문 기술",
        "2": "분석과 중재기술",
        "3": "설계 및 코딩 기술",
        "4": "관찰 및 모델 작성 기술"
      },
      "answer": 3,
      "comment": "요구사항 개발 프로세스 : 도출 → 분석 → 명세 → 확인요구사항 도출 단계 주요 기법은 인터뷰, 설문, 브레인스토밍 등이 있어 청취와 인터뷰 질문 기술이 필요함.<br><br>요구사항 분석 기법에개념 모델링이 있으므로 관찰 및 모델 작성 기술 필요함.<br><br>요구사항 분석 기법에 정형 분석과 요구사항 협상이 있으므로 관찰 및 모델 작성 기술 필요함<br><br>※ 요구사항 분석 기법 : 요구사항 분류, 개념 모델링, 요구사항 할당, 요구사항 협상, 정형 분석"
    }, {
      "num": 2,
      "subject": 1,
      "ask": "다음 내용이 설명하는 디자인 패턴은?",
      "desc": "- 객체를 생성하기 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화 될 것인지는 서브클래스가 결정하도록 하는 것<br>- Virtuai-Constructor 패턴이라고도 함",
      "choice": {
        "1": "Visitor패턴",
        "2": "Observer패턴",
        "3": "Factory Method 패턴",
        "4": "Bridge 패턴"
      },
      "answer": 3,
      "comment": "1. Visitor(방문자) 패턴 &lt;행위 패턴&gt;<br>- 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성함.<br>분리된 처리 기능은 각 클래스를 방문하여 수행<br><br>2. Observer 패턴 &lt;행위 패턴&gt;<br>- 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달.<br>분산된 시스템 간에 이벤트 생성, 발행(Publish), 이를 수신(Subscribe)해야할 때 이용함<br><br>4. Bridge 패턴 &lt;구조 패턴&gt;<br>- 구현부에서 추상층을 분리, 서로가 독립적으로 확장함기능과 구현을 두 개의 별도 클래스로 구현함"
    }, {
      "num": 3,
      "subject": 1,
      "ask": "럼바우 객체 지향 분석과 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "기능 모델링",
        "2": "동적 모델링",
        "3": "객체 모델링",
        "4": "정적 모델링"
      },
      "answer": 4,
      "comment": "- 럼바우(Rumbaugh)의 분석 기법<br>가장 일반적으로 사용되는 방법, 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행함.<br>모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링, 객체 모델링 기법(OMT)이라고도 함.<br><br>- 객체 모델링(Object Modeling) = 정보 모델링<br>시스템에서 요구되는 객체를 찾아내 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시함분석 활동의 세 가지 모델 중 가장 중요!<br><br>- 동적 모델링(Dynamic Modeling)<br>상태 다이어그램(상태도)를 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현함<br><br>- 기능 모델링(Function Modeling)<br>자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름 중심으로 처리 과정을 표현함."
    }, {
      "num": 4,
      "subject": 1,
      "ask": "애자일 기법에 대한 설명으로 맞지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "절차와 도구보다 개인과 소통을 중요하게 생각한다.",
        "2": "계획에 중점을 두어 변경 대응이 난해하다.",
        "3": "소프트웨어가 잘 실행되는데 가치를 둔다.",
        "4": "고객과의 피드백을 중요하게 생각한다."
      },
      "answer": 2,
      "comment": "애자일(Agile) 개발 4가지 핵심 가치<br><br>1. 프로세스와 도구보다는 개인과의 상호작용에 더 가치를 둠<br>2. 방대한 문서보다는 실행되는 SW에 더 가치를 둠<br>3. 계약 협상보다는 고객과의 협업에 더 가치를 둠<br>4. 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둠"
    }, {
      "num": 5,
      "subject": 1,
      "ask": "미들웨어 솔루션의 유형에 포함되지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "WAS",
        "2": "Web Server",
        "3": "RPC",
        "4": "ORB"
      },
      "answer": 2,
      "comment": "1. WAS(웹 애플리케이션 서버)<br>- 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리함<br>- 웹 환경을 구현하기 위한 미들웨어<br><br>2. Web Server<br>- 클라이언트로부터 직접 요청을 받아 처리, 저용량의 정적 파일들을 제공하는 소프트웨어<br><br>3. RPC(Remot Procedure Call)<br>- 응용 프로그램이 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어<br><br>4. ORB(Object Request Broker)<br>- 객체 지향 미들웨어로 코바(CORBA) 표준 스펙을 구현함<br>- 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있음"
    }, {
      "num": 6,
      "subject": 1,
      "ask": "UML에서 시퀀스 다이어그램의 구성 항목에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "생명선",
        "2": "실행",
        "3": "확장",
        "4": "메시지"
      },
      "answer": 3,
      "comment": "시퀀스 다이어그램 구성 항목<br>액터, 활성 객체(object), 라이프라인(생명선), 메세지, 제어 삼각형"
    }, {
      "num": 7,
      "subject": 1,
      "ask": "객체지향에서 정보 은닉과 가장 밀접한 관계가 있는 것은?",
      "desc": "",
      "choice": {
        "1": "Encapsulation",
        "2": "Class",
        "3": "Method",
        "4": "Instance"
      },
      "answer": 1,
      "comment": "정보 은닉 : 캡슐화에서 가장 중요한 개념, 다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통해 접근을 허용"
    }, {
      "num": 8,
      "subject": 1,
      "ask": "디자인 패턴 중에서 행위적 패턴에 속하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "커맨드 (Command) 패턴",
        "2": "옵저버 (Obseerver) 패턴",
        "3": "프로토타입 (Prototype) 패턴",
        "4": "상태 (State) 패턴"
      },
      "answer": 3,
      "comment": "3번 프로토타입(Prototype) 패턴은 생성 패턴(Creational Pattern)이다."
    }, {
      "num": 9,
      "subject": 1,
      "ask": "UI 설계 원칙 중 누구나 쉽게 이해하고 사용할 수 있어야 한다는 원칙은?",
      "desc": "",
      "choice": {
        "1": "희소성",
        "2": "유연성",
        "3": "직관성",
        "4": "멀티운용성"
      },
      "answer": 3,
      "comment": "사용자 인터페이스(UI)의 기본 원칙<br>- 직관성 : 누구나 쉽게 이해하고 사용할 수 있어야 함<br>- 유효성 : 사용자의 목적을 정확하고 완벽하게 달성해야 함<br>- 학습성 : 누구나 쉽게 배우고 익힐 수 있어야 함<br>- 유연성 : 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 함"
    }, {
      "num": 10,
      "subject": 1,
      "ask": "코드의 기본 기능으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "복잡성",
        "2": "표준화",
        "3": "분류",
        "4": "식별"
      },
      "answer": 1,
      "comment": "코드(Code)의 주요 기능<br>- 식별 기능 : 데이터 간의 성격에 따라 구분<br>- 분류 기능 : 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화<br>- 배열 기능 : 의미를 부여하여 나열<br>- 표준화 기능 : 다양한 정보를 컴퓨터에 의해 처리하기 위해서는 단일한 형태의 표준화된 표현이 필요함"
    }, {
      "num": 11,
      "subject": 1,
      "ask": "다음 ( ) 안에 들어갈 내용으로 옳은 것은?",
      "desc": "컴포넌트 설계 시 '()에 의한 설계'를 따를 경우, 해당 명세서에서는<br>(1) 컴포넌트의 오퍼레이션 사용 전에 참이 되어야 할 선행조건<br>(2) 사용 후 만족되어야 할 결과조건<br>(3) 오퍼레이션이 실행되는 동안 항상 만족되어야 할 불변조건 등이 포함되어야 한다.",
      "choice": {
        "1": "협약(Contract)",
        "2": "프로토콜(Protocol)",
        "3": "패턴(Pattern)",
        "4": "관계(Relation)"
      },
      "answer": 1,
      "comment": "클래스에 대한 여러 가정을 공유하도록 명세한 것을 협약에 의한 설계(Design by Contract)라 함.<br>소프트웨어 컴포넌트에 대한 정확한 인터페이스 명세를 위하여 선행조건, 결과조건, 불변조건을 나타내는 설계 방법.<br><br>협약에 의한 설계의 세 가지 타입<br>선행조건(precondition): 오퍼레이션이 호출되기 전에 참이 되어야 할 조건<br>결과조건(postcondition): 오퍼레이션이 수행된 후 만족하여야 하는 조건<br>불변조건(invariant): 클래스 내부가 실행되는 동안 항상 만족하여야 하는 조건(예: 리스트에 있는 노드가 항상 오름차순으로 되어야 함)"
    }, {
      "num": 12,
      "subject": 1,
      "ask": "UML에서 활용되는 다이어그램 중, 시스템의 동작을 표현하는 행위(Behavioral) 다이어그램에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "유스케이스 다이어그램(Use Case Diagram)",
        "2": "시퀀스 다이어그램(Sequence Diagram)",
        "3": "활동 다이어그램(Activity Diagram)",
        "4": "배치 다이어그램(Deployment Diagram)"
      },
      "answer": 4,
      "comment": "4. 배치(Deployment) 다이어그램은 구조적(Structural) 다이어그램이다."
    }, {
      "num": 13,
      "subject": 1,
      "ask": "객체 지향 소프트웨어 공학에서 하나 이상의 유사한 객체들을 묶어서 하나의 공통된 특성을 표현한 것은?",
      "desc": "",
      "choice": {
        "1": "트랜지션",
        "2": "클래스",
        "3": "시퀀스",
        "4": "서브루틴"
      },
      "answer": 2,
      "comment": "클래스(Class)<br>- 클래스는 공통된 속성과 연산(행위)을 갖는 객체의 집합, 객체의 일반적인 타입(Type)을 의미함<br>- 동일 클래스에 속한 각각의 객체들은 공통된 속성과 행위를 가지고 있음"
    }, {
      "num": 14,
      "subject": 1,
      "ask": "아래의 UML 모델에서 '차' 클래스와 각 클래스의 관계로 옳은 것은?",
      "desc": "<img src='../assets/img/quizImg/202003_14.jpg' alt='이미지'>",
      "choice": {
        "1": "추상화 관계",
        "2": "의존 관계",
        "3": "일반화 관계",
        "4": "그룹 관계"
      },
      "answer": 3,
      "comment": "일반화 관계<br>- 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현함<br>- 일반적인 개념을 상위(부모), 구체적인 개념을 하위(자식)이라고 함<br>- 하위 사물에서 상위 사물인 쪽으로 속이 빈 화살표를 연결함"
    }, {
      "num": 15,
      "subject": 1,
      "ask": "객체지향 소프트웨어 설계시 디자인 패턴을 구성하는 요소로서 가장 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "개발자이름",
        "2": "문제 및 배경",
        "3": "사례",
        "4": "샘플코드"
      },
      "answer": 1,
      "comment": "어떤 문제에 대하여 어떤 디자인 패턴을 사용할지 정할때는<br>1. 문제와 배경을 보고<br>2. 과거엔 어떻게 처리했는지 (사례, 샘플코드)를 살펴봅니다."
    }, {
      "num": 16,
      "subject": 1,
      "ask": "자료 사전에서 자료의 반복을 의미하는 것은?",
      "desc": "",
      "choice": {
        "1": "=",
        "2": "()",
        "3": "{}",
        "4": "[]"
      },
      "answer": 3,
      "comment": "자료 사전 표기법<br>= : 자료의 정의<br>+ : 자료의 연결<br>() : 자료의 생략<br>[|] : 자료의 선택<br>{} : 자료의 반복<br>** : 자료의 설명(주석)"
    }, {
      "num": 17,
      "subject": 1,
      "ask": "객체지향 설계 원칙 중, 서브타입(상속받은 하위 클래스)은 어디에서나 자신의 기반타입(상위클래스)으로 교체할 수 있어야 함을 의미하는 원칙은?",
      "desc": "",
      "choice": {
        "1": "ISP(Interface Segregation Principle)",
        "2": "DIP(Dependency Inversion Principle)",
        "3": "LSP(Liskov Substitution Principle)",
        "4": "SRP(Single Responsibility Principle)"
      },
      "answer": 3,
      "comment": "객체지향 설계원칙<br>1. 단일 책임 원칙(SRP, Single Responsibility Principle)객체는 단 하나의 책임만 가져야 한다.<br>2. 개방-폐쇄의 원칙(OCP, Open Closed Principle)기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다.<br>3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)일반화 관계에 대한 이야기며, 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다.<br>4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)인터페이스를 클라이언트에 특화되도록 분리시키라는 설계 원칙이다.<br>5. 의존 역전 원칙(DIP, Dependency Inversion Principle)의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것."
    }, {
      "num": 18,
      "subject": 1,
      "ask": "자료흐름도(Data Flow Diagram)의 구성요소로 옳은 것은?",
      "desc": "",
      "choice": {
        "1": "process, data flow, data store, comment",
        "2": "process, data flow, data store, terminator",
        "3": "data flow, data store, terminator, data dictionary",
        "4": "process, data store, terminator, mini-spec"
      },
      "answer": 2,
      "comment": "자료 흐름도 구성 요소<br>- 프로세스 (Process)<br>- 자료 흐름(Data Flow)<br>- 자료 저장소(Data Store)<br>- 단말(Terminator)"
    }, {
      "num": 19,
      "subject": 1,
      "ask": "CASE(Computer-Aided Software Engineering)도구에 대한 설명으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "소프트웨어 개발 과정의 일부 또는 전체를 자동화하기 위한 도구이다.",
        "2": "표준화된 개발 환경 구축 및 문서 자동화 기능을 제공한다.",
        "3": "작업 과정 및 데이터 공유를 통해 작업자간 커뮤니케이션을 증대한다.",
        "4": "2000년대 이후 소개되었으며, 객체지향 시스템에 한해 효과적으로 활용된다."
      },
      "answer": 4,
      "comment": "소프트웨어 공학의 자동화를 의미, 소프트웨어 공학작업을 자동화한 소프트웨어 패키지를 CASE도구라고 한다.<br>CASE도구들은 소프트웨어 관리자들과 실무자들이 소프트웨어 프로세스와 관련된 활동을 지원한다.<br>즉, 프로젝트 관리 활동을 자동화하고, 결과물을 관리하며, 엔지니어들의 분석, 설계 및 코딩과 테스트작업을 도운다.<br><br>주요기능: 다양한 소프트웨어 개발 모형 지원, 그래픽 지원, 소프트웨어 생명주기의 전단계 연결<br><br>CASE는 1980년대에 소개되었으며, 1990년대부터 자주 사용되었습니다."
    }, {
      "num": 20,
      "subject": 1,
      "ask": "인터페이스 요구 사항 검토 방법에 대한 설명이 옳은 것은?",
      "desc": "",
      "choice": {
        "1": "리팩토링 : 작성자 이외의 전문 검토 그룹이 요구사항 명세서를 상세히 조사하여 결함, 표준 위배, 문제점 등을 파악",
        "2": "동료검토 : 요구 사항 명세서 작성자가 요구 사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견",
        "3": "인스펙션 : 자동화된 요구 사항 관리 도구를 이용하여 요구 사항 추적성과 일관성을 검토",
        "4": "CASE 도구 : 검토 자료를 회의 전에 배포해서 사전 검토한 후 짧은 시간 동안 검토 회의를 진행하면서 결함을 발견"
      },
      "answer": 2,
      "comment": "인터페이스 요구사항 검토(검증) 방법<br>- 동료 검토(Peer Review) : 요구사항 명세서 작성자가 요구사항 명세서를 설명하고 이해관계자들이 설명을 들으면서 결함을 발견<br>- 워크스루(Walk Through) : 검토 회의 전, 명세서를 미리 배포하여 사전검토 후에 짧은 검토 회의를 통해 결함 발견<br>- 인스펙션(Inspection) : 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 명세서를 확인하면서 결함을 발견"
    }, {
      "num": 21,
      "subject": 2,
      "ask": "인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "IPSec",
        "2": "SSL",
        "3": "SMTP",
        "4": "S-HTTP"
      },
      "answer": 3,
      "comment": "1. IPSec : 네트워크 계층에서 IP 패킷 단위의 데이터 변조 방지 및 은닉 기능 제공<br>2. SSL : TCP/IP 계층과 애플리케이션 계층 사이에서 인증, 암호화, 무결성을 보장하는 프로토콜<br>4. S-HTTP : 클라이언트와 서버 간 전송되는 모든 메시지를 암호화하는 프로토콜<br>3. SMTP(Simple Mail Transfer Protocol)은 전자 우편을 교환하는 서비스를 제공하는 프로토콜"
    }, {
      "num": 22,
      "subject": 2,
      "ask": "소프트웨어 공학의 기본 원칙이라고 볼 수 없는 것은?",
      "desc": "",
      "choice": {
        "1": "품질 높은 소프트웨어 상품 개발",
        "2": "지속적인 검증 시행",
        "3": "결과에 대한 명확한 기록 유지",
        "4": "최대한 많은 인력 투입"
      },
      "answer": 4,
      "comment": "많은 인력을 투자한다고 해서 소프트웨어를 빨리 만드는 것은 아니다."
    }, {
      "num": 23,
      "subject": 2,
      "ask": "패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준은?",
      "desc": "",
      "choice": {
        "1": "SO/IEC 2196",
        "2": "IEEE 19554",
        "3": "ISO/IEC 12119",
        "4": "ISO/IEC 14959"
      },
      "answer": 3,
      "comment": "- ISO/IEC 9126 : 소프트웨어 품질 특성 및 척도에 대한 표준화<br>- ISO/IEC 14598 : 소프트웨어 제품 평가. ISO/IEC 9126 사용을 위한 절차와 기본 상황 및 소프트웨어 평가 프로세스에 대한 표준 규정<br>- ISO/IEC 12119 : 패키지 소프트웨어 평가."
    }, {
      "num": 24,
      "subject": 2,
      "ask": "다음 중 클린 코드 작성원칙으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "누구든지 쉽게 이해하는 코드 작성",
        "2": "중복이 최대화된 코드 작성",
        "3": "다른 모듈에 미치는 영향 최소화",
        "4": "단순, 명료한 코드 작성"
      },
      "answer": 2,
      "comment": " 클린 코드 작성 원칙<br>가독성, 단순성, 의존성 배제, 중복성 최소화, 추상화"
    }, {
      "num": 25,
      "subject": 2,
      "ask": "블랙박스 테스트의 유형으로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "경계값 분석",
        "2": "오류 예측",
        "3": "동등 분할 기법",
        "4": "조건, 루프 검사"
      },
      "answer": 4,
      "comment": "블랙박스 테스트 유형<br>- 동치(동등) 분할 검사(Equivalence Partitioning Testing)<br>- 경계값 분석(Boundary Value Analysis)<br>- 원인-효과 그래프 검사(Cause-Effect Graphing Testing)<br>- 오류 예측 검사(Error Guessing)<br>- 비교 검사(Comparison Testing)<br><br>화이트박스 테스트 유형<br>- 기초 경로 검사<br>- 제어 구조 검사<br>- 조건 검사(Condition Testing)<br>- 루프 검사(Loop Testing)<br>- 데이터 흐름 검사(Data Flow Testing)"
    }, {
      "num": 26,
      "subject": 2,
      "ask": "제어흐름 그래프가 다음과 같을 때 McCabe의 cyclomatic 수는 얼마인가?",
      "desc": "<img src='../assets/img/quizImg/202003_26.jpg' alt='이미지'>",
      "choice": {
        "1": "3",
        "2": "4",
        "3": "5",
        "4": "6"
      },
      "answer": 2,
      "comment": "V(G) = Edge - Node + 2<br><br>Edge = 6 (화살표)<br>Node = 4 (동그라미)<br><br>V(G) = 6 - 4 + 2 = 4"
    }, {
      "num": 27,
      "subject": 2,
      "ask": "다음 자료에 대하여 선택(Selection) 정렬을 이용하여 오름차순으로 정렬하고자 한다. 3회전 후의 결과로 옳은 것은?",
      "desc": "<img src='../assets/img/quizImg/202003_27.jpg' alt='이미지'>",
      "choice": {
        "1": "14, 17, 37, 40, 35",
        "2": "14, 37, 17, 40, 35",
        "3": "17, 14, 37, 35, 40",
        "4": "14, 17, 35, 40, 37"
      },
      "answer": 4,
      "comment": "선택정렬은 가장 작은 값을 찾아 첫번째 값과 교환합니다.이후 정렬된 값을 제외한 나머지 인덱스 중 가장 작은 값을 찾아 정렬되지않은 인덱스 중 가장 처음 값과 자리를 교환해 나아갑니다.<br><br>1회전 14 37 17 40 35<br>2회전 14 17 37 40 35<br>3회전 14 17 35 40 37"
    }, {
      "num": 28,
      "subject": 2,
      "ask": "형상 관리 도구의 주요 기능으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "정규화(Normalization)",
        "2": "체크인(Check-in)",
        "3": "체크아웃(Check-out)",
        "4": "커밋(commit)"
      },
      "answer": 1,
      "comment": "소프트웨어 버전 등록 관련 주요 용어<br>- 저장소(Repository) : 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳<br>- 가져오기(Import) : 버전 관리가 되고 있지 않은 아무것도 없는 저장소에 처음으로 파일을 복사<br>- 체크아웃(Check-Out) : 프로그램을 수정하기 위해 저장소에서 파일을 받아 옴. 소스 파일과 함께 버전 관리를 위한 파일들도 받음<br>- 체크인(Check-In) : 체크아웃 한 파일의 수정을 완료한 후 저장소의 파일을 새로운 버전으로 갱신<br>- 커밋(Commit) : 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우 충동을 알리고 diff 도구를 이용해 수정 후 갱신 완료<br>- 동기화(Update) : 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화함"
    }, {
      "num": 29,
      "subject": 2,
      "ask": "다음 트리를 Preorder 운행법으로 운행할 경우 가장 먼저 탐색되는 것은?",
      "desc": "<img src='../assets/img/quizImg/202003_29.jpg' alt='이미지'>",
      "choice": {
        "1": "A",
        "2": "B",
        "3": "D",
        "4": "G"
      },
      "answer": 1,
      "comment": "이진 트리 운행법<br>- Preorder 운행 : Root → Left → Right 순으로 운행<br>- Inorder 운행 : Left → Root → Right 순으로 운행<br>- Postorder 운행 : Left → Right → Root 순으로 운행"
    }, {
      "num": 30,
      "subject": 2,
      "ask": "소프트웨어 품질 목표 중 주어진 시간동안 주어진 기능을 오류없이 수행하는 정도를 나타내는 것은?",
      "desc": "",
      "choice": {
        "1": "직관성",
        "2": "사용 용이성",
        "3": "신뢰성",
        "4": "이식성"
      },
      "answer": 3,
      "comment": "소프트웨어 품질기능성 : 사용자 요구사항을 정확하게 만족하는 기능을 제공하는지 여부<br>신뢰성 : 요구된 기능을 정확하고 일관되게 오류없이 수행할 수 있는 정도<br>사용성 : 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대해 사용자가 정확하게 이해하고 사용하며 향후 다시 사용하고 싶은 정도<br>효율성 : 요구하는 기능을 할당된 시간동안 한정된 자원으로 얼마나 빨리 처리할 수 있는지 정도<br>유지 보수성 : 환경 변화 or 새 요구사항 발생 시 소프트웨어 개선 및 확장할 수 있는 정도<br>이식성 : 타 환경에서도 얼마나 쉽게 적용할 수 있는지 정도"
    }, {
      "num": 31,
      "subject": 2,
      "ask": "알고리즘 설계 기법으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "Divide and Conquer",
        "2": "Greedy",
        "3": "Static Block",
        "4": "Backtracking"
      },
      "answer": 3,
      "comment": "1.Divide and Conquer(분할 정복 알고리즘) : 그대로 해결할 수 없는 문제를 작은 문제로 분할하여 문제를 해결하는 알고리즘<br>2. Greedy(탐욕 알고리즘) : 현재 시점에서 가장 최적의 방법을 선택하는 알고리즘<br>4. Backtracking : 모든 조합을 시도하여 문제의 답을 찾는 알고리즘"
    }, {
      "num": 32,
      "subject": 2,
      "ask": "제품 소프트웨어의 형상 관리 역할로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "형상 관리를 통해 이전 리버전이나 버전에 대한 정보에 접근 가능하여 배포본 관리에 유용",
        "2": "불필요한 사용자의 소스 수정 제한",
        "3": "프로젝트 개발비용을 효율적으로 관리",
        "4": "동일한 프로젝트에 대해 여러 개발자 동시 개발 가능"
      },
      "answer": 3,
      "comment": "형상관리는 프로젝트의 버전, 수정사항을 관리하지개발 비용을 관리하지는 않습니다."
    }, {
      "num": 33,
      "subject": 2,
      "ask": "제품 소프트웨어 패키징 도구 활용 시 고려사항이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "제품 소프트웨어의 종류에 적합한 암호화 알고리즘을 고려한다",
        "2": "추가로 다양한 이기종 연동을 고려한다.",
        "3": "사용자 편의성을 위한 복잡성 및 비효율성 문제를 고려한다.",
        "4": "내부 콘텐츠에 대한 보안은 고려하지 않는다."
      },
      "answer": 4,
      "comment": "제품 소프트웨어의 패키징 활용 시 고려사항<br>- 패키징 시 사용자에게 배포 되는 소프트웨어 임을 감안하여 반드시 내부 콘텐츠에 대한 암호화 및 보안을 고려한다.<br>- 패키징 도구를 활용하여 여러 가지 이기종 콘텐츠 및 단말기 간 DRM 연동을 고려한다.<br>- 패키징 도구를 고려하면 사용자의 입장에서 불편해질 수 있는 문제를 고려하여 최대한 효율적으로 적용될 수 있도록 한다.<br>-암호화 알고리즘이 여러 가지 종류가 있는데 제품 소프트웨어의 종류에 맞는 알고리즘을 선택하여 배포시 범용성에 지장이 없도록 고려한다."
    }, {
      "num": 34,
      "subject": 2,
      "ask": "디지털 저작권 관리(DRM) 기술과 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "콘텐츠 암호화 및 키 관리",
        "2": "콘텐츠 식별체계 표현",
        "3": "콘텐츠 오류 감지 및 복구",
        "4": "라이센스 발급 및 관리"
      },
      "answer": 3,
      "comment": "디지털 저작권 관리(DRM) 기술 요소<br>- 암호화(Encryption) : 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술<br>- 키 관리(Key Management) : 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술<br>- 암호화 파일 생성(Packager) : 콘텐트를 암호화된 콘텐츠로 생성하기 위한 기술<br>- 식별 기술(Identification) : 콘텐츠에 대한 식별 체계 표현 기술<br>- 저작권 표현(Right Expression) : 라이선스의 내용 표현 기술<br>- 정책 관리(Policy Management) : 라이선스 발급 및 사용에 대한 정책 표현 및 관리 기술<br>- 크랙 방지(Tamper Resistance) : 크랙에 의한 콘텐츠 사용 방지 기술<br>- 인증(Authentication) : 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술"
    }, {
      "num": 35,
      "subject": 2,
      "ask": "물리데이터 저장소의 파티션 설계에서 파티션 유형으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "범위분할(Range Partitioning)",
        "2": "해시분할(Hash Partitioning)",
        "3": "조합분할(Composite Partitioning)",
        "4": "유닛분할(Unit Partitioning)"
      },
      "answer": 4,
      "comment": "파티션 유형 <br>- 범위 분할(Range Partitioning) : 지정한 열의 값을 기준으로 분할<br>- 해시 분할(Hash Partitioning) : 해시 함수를 적용한 결과 값에 따라 데이터 분할<br>- 조합 분할(Composite Partitioning) : 범위 분할 후 해시 함수를 적용하여 다시 분할"
    }, {
      "num": 36,
      "subject": 2,
      "ask": "다음이 설명하는 애플리케이션 통합 테스트 유형은?",
      "desc": "- 깊이 우선 방식 또는 너비 우선 방식이 있다.<br>- 상위 컴포넌트를 테스트 하고 점증적으로 하위 컴포넌트를 테스트 한다.<br>하위 커포넌트 개발이 완료되지 않은 경우 스텁(Stub)을 사용하기도 한다.",
      "choice": {
        "1": "하향식 통합 테스트",
        "2": "상향식 통합 테스트",
        "3": "회귀 테스트",
        "4": "빅뱅 테스트"
      },
      "answer": 1,
      "comment": "상향식 통합 테스트<br>- 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트<br>- 하나의 주요 제어 모듈과 관련된 종속 모듈의 그룹인 클러스터 필요<br>- 상위 모듈 개발이 완료되지 않은 경우 드라이버(Driver)를 사용하기도 함회귀 테스트(Regression Testing)<br>- 이미 테스트된 프로그램의 테스팅 반복<br>- 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인빅뱅 테스트<br>- 통합 테스트(Integration Test) 중 비점진적 통합 방식"
    }, {
      "num": 37,
      "subject": 2,
      "ask": "인터페이스 구현시 사용하는 기술 중 다음 내용이 설명하는 것은?",
      "desc": "JavaScript를 사용한 비동기 통신기술로 클라이언트와 서버간에 XML 데이터를 주고 받는 기술",
      "choice": {
        "1": "Procedure",
        "2": "Trigger",
        "3": "Greedy",
        "4": "AJAX"
      },
      "answer": 4,
      "comment": "1. Procedure : 절차형 SQL을 활용하여 특정 기능을 수행하는 일종의 트랜잭션 언어<br>2. Trigger : 데이터의 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL<br>3. Greedy : 탐욕 알고리즘"
    }, {
      "num": 38,
      "subject": 2,
      "ask": "소프트웨어 재공학이 소프트웨어의 재개발에 비해 갖는 장점으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "위험부담 감소",
        "2": "비용 절감",
        "3": "시스템 명세의 오류억제",
        "4": "개발시간의 증가"
      },
      "answer": 4,
      "comment": "상식적으로 생각하였을 경우, SW를 첨부터 다시 개발하는거보다는 재공학 하는것이 더 시간적으로 절약된다."
    }, {
      "num": 39,
      "subject": 2,
      "ask": "알파, 베타 테스트와 가장 밀접한 연관이 있는 테스트 단계는?",
      "desc": "",
      "choice": {
        "1": "단위 테스트",
        "2": "인수 테스트",
        "3": "통합 테스트",
        "4": "시스템 테스트"
      },
      "answer": 2,
      "comment": "인수 테스트(Acceptance Test) 종류<br>- 사용자 인수 테스트<br>- 운영상의 인수 테스트<br>- 계약 인수 테스트<br>- 규정 인수 테스트<br>- 알파 테스트<br>- 베타 테스트"
    }, {
      "num": 40,
      "subject": 2,
      "ask": "다음 트리의 차수(degree)는?",
      "desc": "<img src='../assets/img/quizImg/202003_40.jpg' alt='이미지'>",
      "choice": {
        "1": "2",
        "2": "3",
        "3": "4",
        "4": "5"
      },
      "answer": 2,
      "comment": "트리의 차수 : 전체 트리 중에서 가장 많은 차수"
    }, {
      "num": 41,
      "subject": 3,
      "ask": "릴레이션 R의 모든 결정자(determinant)가 후보키이면 그 릴레이션 R은 어떤 정규형에 속하는가?",
      "desc": "",
      "choice": {
        "1": "제 1 정규형",
        "2": "제 2 정규형",
        "3": "보이스/코드 정규형",
        "4": "제 4 정규형"
      },
      "answer": 3,
      "comment": "제1정규형 = 반복그룹을 제거<br>제2정규형=부분 함수적 종속 제거<br>제4정규형=다치종속 제거<br>보이스/코드= 모든 결정자가 후보키인 상태"
    }, {
      "num": 42,
      "subject": 3,
      "ask": "다음 관계형 데이터 모델에 대한 설명으로 옳은 것은?",
      "desc": "<img src='../assets/img/quizImg/202003_42.jpg' alt='이미지'>",
      "choice": {
        "1": "relation 3개, attribute 3개, tuple 5개",
        "2": "relation 3개, attribute 5개, tuple 3개",
        "3": "relation 1개, attribute 5개, tuple 3개",
        "4": "relation 1개, attribute 3개, tuple 5개"
      },
      "answer": 4,
      "comment": "relation : 테이블의 수<br>attribute : 열의 수<br>tuple : 행의 수"
    }, {
      "num": 43,
      "subject": 3,
      "ask": "Commit과 Rollback 명령어에 의해 보장 받는 트랜잭션의 특성은?",
      "desc": "",
      "choice": {
        "1": "병행성",
        "2": "보안성",
        "3": "원자성",
        "4": "로그"
      },
      "answer": 3,
      "comment": "원자성 : 트랜잭션 연산은 DB에 모두 반영되어 Commit(완료)되든지 아니면 반영안되어 Rollback(복구)되어야 한다.<br>일관성 : 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성있는 데이터베이스 상태로 변환한다.<br>독립성 : 둘 이상 트랜잭션이 동시 병행 실행될 경우 트랜잭션 실행 중 타 트랜잭션의 연산이 끼어들 수 없다.<br>지속성 : 성공적 완료된 트랜잭션 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다."
    }, {
      "num": 44,
      "subject": 3,
      "ask": "관계 데이터베이스인 테이블 R1에 대한 아래 SQL 문의 실행결과로 옳은 것은?",
      "desc": "<img src='../assets/img/quizImg/202003_44.jpg' alt='이미지'>",
      "choice": {
        "1": "<img src='../assets/img/quizImg/202003_44_1.jpg' alt='이미지'>",
        "2": "<img src='../assets/img/quizImg/202003_44_2.jpg' alt='이미지'>",
        "3": "<img src='../assets/img/quizImg/202003_44_3.jpg' alt='이미지'>",
        "4": "<img src='../assets/img/quizImg/202003_44_4.jpg' alt='이미지'>"
      },
      "answer": 2,
      "comment": "DISTINCT : 중복 튜플 발견 시 그 중 첫번째 하나만 검색"
    }, {
      "num": 45,
      "subject": 3,
      "ask": "DCL(Data Control Language) 명령어가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "COMMIT",
        "2": "ROLLBACK",
        "3": "GRANT",
        "4": "GRANT"
      },
      "answer": 4,
      "comment": "DCL(Data Control Language) : 데이터베이스 관리자(DBA)가 데이터 관리를 목적으로 사용되는 명령어를 뜻한다.<br>1. GRANT: 데이터베이스 사용자에게 사용권한을 부여하는 명령어<br>2. REVOKE: 데이터베이스 사용자의 사용권한을 취소하는 명령어<br>3. COMMIT: 데이터베이스 조작 작업이 정상적으로 완료 되었음을 알려주는 명령어<br>4. ROLLBACK: 데이터베이스 조작 작업이 비정상적으로 작동하여 원래 상태로 복구하는 명령어"
    }, {
      "num": 46,
      "subject": 3,
      "ask": "병행제어 기법 중 로킹에 대한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "로킹의 대상이 되는 객체의 크기를 로킹 단위라고 한다.",
        "2": "데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",
        "3": "로킹의 단위가 작아지면 로킹 오버헤드가 증가한다.",
        "4": "로킹의 단위가 커지면 데이터베이스 공유도가 증가한다."
      },
      "answer": 4,
      "comment": "로킹 단위가 크면 나머지가 다 작아짐 / 로킹 단위가 작으면 나머지가 다 커짐"
    }, {
      "num": 47,
      "subject": 3,
      "ask": "관계 데이터모델의 무결성 제약 중 기본키 값의 속성 값이 널(Null)값이 아닌 원자 값을 갖는 성질은?",
      "desc": "",
      "choice": {
        "1": "개체 무결성",
        "2": "참조 무결성",
        "3": "도메인 무결성",
        "4": "튜플의 유일성"
      },
      "answer": 1,
      "comment": "1. 개체 무결성 : 기본키는 null 값이 될 수 없음<br>2. 참조 무결성 : 외래키는 참조할 수 없는 값을 가질 수 없음<br>3. 도메인 무결성 : 특정 속성값은 그 속성이 정의된 도메인에 속한 값이어야 함<br>4. 키 무결성 : 릴레이션에는 최소한 하나의 키가 존재해야 함<br>5. null 무결성 : 특정 속성은 null 값을 가질 수 없음<br>6. 고유 무결성 : 특정 속성값은 서로 달라야 함"
    }, {
      "num": 48,
      "subject": 3,
      "ask": "뷰(View)의 장점이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "뷰 자체로 인덱스를 가짐",
        "2": "데이터 보안 용이",
        "3": "논리적 독립성 제공",
        "4": "사용자 데이터 관리 용이"
      },
      "answer": 1,
      "comment": "뷰는 하나이상의 테이블로부터 유도되는 가상테이블이며 논리적 독립성이 제공됩니다.실제테이블처럼 권한을 나눌 수 있습니다."
    }, {
      "num": 49,
      "subject": 3,
      "ask": "분산 데이터베이스의 투명성(Transparency)에 해당 하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "Location Transparency",
        "2": "Replication Transparency",
        "3": "Failure Transparency",
        "4": "Media Access Transparency"
      },
      "answer": 4,
      "comment": "분할 투명성(단편화) : 하나의 논리적 Relation이 여러 단편으로 분할되어 각 단편의 사본이 여러 사이트에 저장<br>위치 투명성 : 사용하려는 데이터의 저장장소를 명시가 필요하지 않음. 위치정보는 System Caltalog에 유지어야 함<br>지역사상 투명성 : 지역DBMS와 물리적 DB사이의 Mapping 보장. 각 지역시스템 이름과 무관한 이름 사용가능<br>중복 투명성 : DB객체가 여러 사이트에 중복되어 있는지 알 필요가 없는 성질<br>장애 투명성 : 구성요소(DBMS, Computer)의 장애에 무관한 트랜잭션의 원자성유지<br>병행 투명성 : 다수 트랜잭션 동시수행시 결과의 일관성 유지, TImm Stamp, 분산2단계 Locking을 이용하여 구현"
    }, {
      "num": 50,
      "subject": 3,
      "ask": "정규화의 목적으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "어떠한 릴레이션이라도 데이터베이스 내에서 표현 가능하게 만든다.",
        "2": "데이터 삽입시 릴레이션을 재구성할 필요성을 줄인다.",
        "3": "중복을 배제하여 삽입, 삭제, 갱신 이상의 발생을 야기한다.",
        "4": "효과적인 검색 알고리즘을 생성할 수 있다."
      },
      "answer": 3,
      "comment": "중복을 배제하여 삽입, 삭제, 갱신 이상들을 제거하기 위하여 정규화를 합니다."
    }, {
      "num": 51,
      "subject": 3,
      "ask": "다음에 해당하는 함수 종속의 추론 규칙은?(오류 신고가 접수된 문제입니다. 반드시 정답과 해설을 확인하시기 바랍니다.)",
      "desc": "<img src='../assets/img/quizImg/202003_51.jpg' alt='이미지'>",
      "choice": {
        "1": "분해 규칙",
        "2": "이행 규칙",
        "3": "반사 규칙",
        "4": "결합 규칙"
      },
      "answer": 2,
      "comment": "[오류 신고 내용]<br>반사규칙은 X ⊇ Y이면 X -> Y와 X -> X이다."
    }, {
      "num": 52,
      "subject": 3,
      "ask": "다음 R과 S 두 릴레이션에 대한 Division 연산의 수행 결과는?",
      "desc": "<img src='../assets/img/quizImg/202003_52.jpg' alt='이미지'>",
      "choice": {
        "1": "<img src='../assets/img/quizImg/202003_52_1.jpg' alt='이미지'>",
        "2": "<img src='../assets/img/quizImg/202003_52_2.jpg' alt='이미지'>",
        "3": "<img src='../assets/img/quizImg/202003_52_3.jpg' alt='이미지'>",
        "4": "<img src='../assets/img/quizImg/202003_52_4.jpg' alt='이미지'>"
      },
      "answer": 4,
      "comment": "DIVISION<br>- Division은 X ⊃ Y 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산이다.<br>- 연산자의 기호는 ÷를 사용<br>- 표기 형식 : R [속성r ÷ 속성s] S"
    }, {
      "num": 53,
      "subject": 3,
      "ask": "player 테이블에는 player_name, team_id, height 컬럼이 존재한다. 아래 SQL문에서 문법적 오류가 있는 부분은?",
      "desc": "(1) SELECT player_name,height<br>(2) FROM player <br>(3) WHERE team_id = 'Korea' <br>(4) AND height BETWEEN 170 or 180",
      "choice": {
        "1": "(1)",
        "2": "(2)",
        "3": "(3)",
        "4": "(4)"
      },
      "answer": 4,
      "comment": "BETWEEN A OR B라는 문법은 없습니다"
    }, {
      "num": 54,
      "subject": 3,
      "ask": "데이터베이스 로그(log)를 필요로 하는 회복 기법은?",
      "desc": "",
      "choice": {
        "1": "즉각 갱신 기법",
        "2": "대수적 코딩 방법",
        "3": "타임 스탬프 기법",
        "4": "폴딩 기법"
      },
      "answer": 1,
      "comment": "즉각 갱신 기법(Immediate Update) : 트랜잭션의 연산을 수행하여 데이터를 갱신할 때 실제 데이터 베이스에 반영하는 기법<br>갱신한 모든 내용을 로그(Log)에 보관합니다.회복 작업을 위해 취소(Undo)와 재시도(Redo) 모두 사용할 수 있습니다."
    }, {
      "num": 55,
      "subject": 3,
      "ask": "DML(Data Manipulation Language) 명령어가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "INSERT",
        "2": "UPDATE",
        "3": "ALTER",
        "4": "DELETE"
      },
      "answer": 3,
      "comment": "DML(데이터 조작어) : SELECT / INSERT / DELETE / UPDATE *<br>DDL(데이터 정의어) : CREATE / ALTER / DROP<br>DCL(데이터 제어어) : COMMIT / ROLLBACK / GRANT / REVOKE"
    }, {
      "num": 56,
      "subject": 3,
      "ask": "다음과 같이 위쪽 릴레이션을 아래쪽 릴레이션으로 정규화를 하였을 때 어떤 정규화 작업을 한 것인가?",
      "desc": "<img src='../assets/img/quizImg/202003_56.jpg' alt='이미지'>",
      "choice": {
        "1": "제 1정규형",
        "2": "제 2정규형",
        "3": "제 3정규형",
        "4": "제 4정규형"
      },
      "answer": 1,
      "comment": "서울, 부산 / 워싱턴, 뉴욕을 도메인에서의 원자값으로만 구성되게 정규화 작업을 함"
    }, {
      "num": 57,
      "subject": 3,
      "ask": "관계대수의 순수관계 연산자가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "Select",
        "2": "Cartesian Product",
        "3": "Division",
        "4": "Project"
      },
      "answer": 2,
      "comment": "순수 관계 연산자 : select / project / join / division"
    }, {
      "num": 58,
      "subject": 3,
      "ask": "다음 중 SQL의 집계 함수(aggregation function)가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "AVG",
        "2": "COUNT",
        "3": "SUM",
        "4": "CREATE"
      },
      "answer": 4,
      "comment": "AVG: 해당 집계행의 평균<br>SUM: 해당 집계행의 합<br>COUNT: 집계행의 수"
    }, {
      "num": 59,
      "subject": 3,
      "ask": "릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상을 의미하는 것은?",
      "desc": "",
      "choice": {
        "1": "normalization",
        "2": "rollback",
        "3": "cardinality",
        "4": "anomaly"
      },
      "answer": 4,
      "comment": "Anomaly(이상) = 릴레이션 조작 시 데이터들이 불필요하게 중복되어 예기치 않게 발생하는 곤란한 현상"
    }, {
      "num": 60,
      "subject": 3,
      "ask": "릴레이션에 대한 설명으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.",
        "2": "한 릴레이션에 포함된 튜플들은 모두 상이하다.",
        "3": "애트리뷰트는 논리적으로 쪼갤 수 없는 원자값으로 저장한다.",
        "4": "한 릴레이션에 포함된 튜플 사이에는 순서가 있다."
      },
      "answer": 4,
      "comment": "릴레이션 특징<br>똑같은 튜플 포함안됨<br>튜플사이 순서 없음<br>속성간 순서 중요x<br>속성의 명칭은 유일 구성값은 동일값 가능<br>속성 값은 원자값"
    }, {
      "num": 61,
      "subject": 4,
      "ask": "다음 자바 프로그램 조건문에 대해 삼항 조건 연산자를 사용하여 옳게 나타낸 것은?",
      "desc": "int l = 7, j = 9;<br>int k;<br>if(i &gt; j)<br>&nbsp;&nbsp;&nbsp;&nbsp;k = i - j;<br>eles<br>&nbsp;&nbsp;&nbsp;&nbsp;k = i + j;",
      "choice": {
        "1": "int i = 7, j = 9;<br>int k;<br>k = (i＞j)?(i – j):(i + j);",
        "2": "int i = 7, j = 9;<br>int k;<br>k = (i＜j)?(i – j):(i + j);",
        "3": "int i = 7, j = 9;<br>int k;<br>k = (i＞j)?(i + j):(i - j);",
        "4": "int i = 7, j = 9;<br>int k;<br>k = (i＜j)?(i + j):(i - j);"
      },
      "answer": 1,
      "comment": "k=(i>j)?(1)(2)<br>(1) 참 값 = 문제에서의 참 값 : i-j;<br>(2) 거짓 값 = 문제에서의 거짓 값 : i+j;<br>따라서 정답은 k=(i>j)?(i-j):(i+j); = 1번"
    }, {
      "num": 62,
      "subject": 4,
      "ask": "다음 내용이 설명하는 소프트웨어 취약점은?",
      "desc": "메모리를 다루는 데 오류가 발생하여 잘못된 동작을 하는 프로그램 취약점",
      "choice": {
        "1": "FTP 바운스 공격",
        "2": "SQL 삽입",
        "3": "버퍼 오버플로",
        "4": "디렉토리 접근 공격"
      },
      "answer": 3,
      "comment": "(1)은 네트워크 공격방법, (2),(4)는 웹관련 공격방법 (3)은 어플리케이션 공격방법이다."
    }, {
      "num": 63,
      "subject": 4,
      "ask": "다음 중 bash 쉘 스크립트에서 사용할 수 있는 제어문이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "if",
        "2": "for",
        "3": "repeat_do",
        "4": "while"
      },
      "answer": 3,
      "comment": "셸 명령어 중 repeat_do라는 명령어는 없다"
    }, {
      "num": 64,
      "subject": 4,
      "ask": "IPv6에 대한 설명으로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "32비트의 주소체계를 사용한다.",
        "2": "멀티미디어의 실시간 처리가 가능하다.",
        "3": "IPv4보다 보안성이 강화되었다.",
        "4": "자동으로 네트워크 환경구성이 가능하다."
      },
      "answer": 1,
      "comment": "IPv6<br>128비트 주소를 사용 주소부족 문제 해결 및 자료 전송 속도 빠름<br>인증성 기밀성 데이터 무결성 지원으로 보안문제 해결<br>확장성 융통성 연동성이 뛰어나며 실시간 흐름 제어로 향상된 멀티미디어 기능 지원<br>16비트 씩 8부분 총 128비트로 구성<br>유니캐스트(unicast) 멀티캐스트(multicast) 애니캐스트(anycast) 세 가지 주소 체계"
    }, {
      "num": 65,
      "subject": 4,
      "ask": "효과적인 모듈 설계를 위한 유의사항으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.",
        "2": "복잡도와 중복성을 줄이고 일관성을 유지시킨다.",
        "3": "모듈의 기능은 예측이 가능해야 하며 지나치게 제한적 이여야 한다.",
        "4": "유지보수가 용이해야 한다."
      },
      "answer": 3,
      "comment": "* 결합도는 줄이고 응집도는 높여서 모듈의 독립성을 높인다.<br>* 모듈의 제어 영역 안에서 그 모듈의 영향 영역을 유지시킨다.<br>* 복잡도와 중복성을 줄이고 일관성을 유지시킨다.<br>* 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다.<br>* 유지보수가 용이해야 한다.<br>* 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해한다.<br>* 하나의 입구와 하나의 출구를 갖도록 해야 한다.<br>* 인덱스 번호나 기능 코드들이 전반적인 처리 논리 구조에 예기치 못한 영향을 끼치지 않도록 모듈 인터페이스를 설계해야 한다."
    }, {
      "num": 66,
      "subject": 4,
      "ask": "HRN 방식으로 스케줄링 할 경우, 입력된 작업이 다음과 같을 때 처리되는 작업 순서로 옳은 것은?",
      "desc": "<img src='../assets/img/quizImg/202003_66.png' alt='이미지'>",
      "choice": {
        "1": "A→B→C→D",
        "2": "A→C→B→D",
        "3": "D→B→C→A",
        "4": "D→A→B→C"
      },
      "answer": 3,
      "comment": "HRN 방식의 우선순위 산정 공식<br>(대기시간+서비스시간)/서비스 시간 (값이 클 수록 우선순위가 높다.)"
    }, {
      "num": 67,
      "subject": 4,
      "ask": "운영체제에 대한 설명으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "다중 사용자와 다중 응용프로그램 환경하에서 자원의 현재 상태를 파악하고 자원 분배를 위한 스케줄링을 담당한다.",
        "2": "CPU, 메모리 공간, 기억 장치, 입출력 장치 등의 자원을 관리한다.",
        "3": "운영체제의 종류로는 매크로 프로세서, 어셈블러, 컴파일러 등이 있다.",
        "4": "입출력 장치와 사용자 프로그램을 제어한다."
      },
      "answer": 3,
      "comment": "매크로 프로세서 : 시스템 소프트웨어<br>어셈블러 : 기계어와 프로그래밍 언어의 중간정도의 언어<br>컴파일러 : 특정 언어를 타 언어로 옮기는 프로그램"
    }, {
      "num": 68,
      "subject": 4,
      "ask": "배치 프로그램의 필수 요소에 대한 설명으로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "자동화는 심각한 오류 상황 외에는 사용자의 개입 없이 동작해야 한다.",
        "2": "안정성은 어떤 문제가 생겼는지, 언제 발생했는지 등을 추적할 수 있어야 한다.",
        "3": "대용량 데이터는 대용량의 데이터를 처리할 수 있어야 한다.",
        "4": "무결성은 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다."
      },
      "answer": 4,
      "comment": "견고함 : 유효하지 않은 데이터의 경우도 처리해서 비정상적인 동작 중단이 발생하지 않아야 한다<br><br>성능 : 주어진 시간 내에 처리를 완료할 수 있어야 하고, 동시에 동작하고 있는 다른 애플리케이션을 방해하지 말아야 한다."
    }, {
      "num": 69,
      "subject": 4,
      "ask": "TCP 프로토콜에 대한 설명으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "신뢰성이 있는 연결 지향형 전달 서비스이다.",
        "2": "기본 헤더 크기는 100byte이고 160byte까지 확장 가능하다.",
        "3": "스크림 전송 기능을 제공한다.",
        "4": "순서제어, 오류제어, 흐름제어 기능을 제공한다."
      },
      "answer": 2,
      "comment": "기본 헤더 크기는 최소 20byte 최대 60byte / 헤더에 Option값 포함 시 최대 40byte 추가 가능"
    }, {
      "num": 70,
      "subject": 4,
      "ask": "다음이 설명하는 응집도의 유형은?",
      "desc": "모듈이 다수의 관련 기능을 가질 때 모듈안의 구성 요소들이 그 기능을 순차적으로 수팽할 경우의 응집도",
      "choice": {
        "1": "기능적 응집도",
        "2": "우연적 응집도",
        "3": "논리적 응집도",
        "4": "절차적 응집도"
      },
      "answer": 4,
      "comment": "우연적 : 서로 관련없는 요소로만 구성<br>논리적 : 유사 성격이나 특정 형태로 분리되는 처리요소들로 모듈 형성<br>시간적 : 특정 시간에 처리되는 몇개의 기능을 모아 모듈로 구성<br>절차적 :모듈 안 구성요소들이 기능을 '순차적'으로 수행 <br>교환적 : 동일 입출력 사용 시 서로 다른 기능을 수행하는 구성요소가 모였을 경우<br>순차적 : 활동을 통해 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용하는 경우<br>기능적 : 모든 기능 요소가 단일 문제와 연관되어 수행될 경우"
    }, {
      "num": 71,
      "subject": 4,
      "ask": "OSI-7Layer에서 링크의 설정과 유지 및 종료를 담당하며, 노드간의 오류제어와 흐름제어 기능을 수행하는 계층은?",
      "desc": "",
      "choice": {
        "1": "데이터링크 계층",
        "2": "물리 계층",
        "3": "세션 계층",
        "4": "응용 계층"
      },
      "answer": 1,
      "comment": "데이터링크 계층송수신 측 속도 차이 해결을 위한 흐름제어 기능 및오류 검출과 회복을 위한 오류제어 기능프레임 시작 및 끝을 구분하기 위한 동기화 기능프레임 순서적 전송을 위한 순서 제어 기능<br><br>물리 : 전송에 필요한 장치 간 실제 접속<br>세션 : 송수신 측 간 관련성 유지 및 대화 제어 / 체크점(동기점)을 두어 정보 수신상태체크<br>응용 : 사용자가 OSI 환경에 접근 가능하도록 서비스 제공"
    }, {
      "num": 72,
      "subject": 4,
      "ask": "다음 중 가장 결합도가 강한 것은?",
      "desc": "",
      "choice": {
        "1": "data coupling",
        "2": "stamp coupling",
        "3": "common coupling",
        "4": "control coupling"
      },
      "answer": 3,
      "comment": "자료data - 스탬프stamp - 제어Control - 외부External - 공통Common - 내용Content"
    }, {
      "num": 73,
      "subject": 4,
      "ask": "메모리 관리 기법 중 Worst fit 방법을 사용할 경우 10K 크기의 프로그램 실행을 위해서는 어느 부분에 할당되는가?",
      "desc": "<img src='../assets/img/quizImg/202003_73.png' alt='이미지'>",
      "choice": {
        "1": "NO.1",
        "2": "NO.2",
        "3": "NO.3",
        "4": "NO.4"
      },
      "answer": 4,
      "comment": "Worst fit (최악 적합) : 들어갈 수 있는 영역 중 자원 낭비가 제일 심한 영역에 들어가는 방법"
    }, {
      "num": 74,
      "subject": 4,
      "ask": "200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 Subnet으로 나누고 ip subnet-zero를 적용했다. 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP주소는?",
      "desc": "",
      "choice": {
        "1": "200.1.1.159",
        "2": "201.1.5.175",
        "3": "202.1.11.254",
        "4": "203.1.255.245"
      },
      "answer": 1,
      "comment": "200.1.1.0 / 서브넷 255.255.255.0"
    }, {
      "num": 75,
      "subject": 4,
      "ask": "다음은 사용자로부터 입력받은 문자열에서 처음과 끝의 3글자를 추출한 후 합쳐서 출력하는 파이썬 코드에서 ㉠에 들어갈 내용은?",
      "desc": "<img src='../assets/img/quizImg/202003_75.png' alt='이미지'>",
      "choice": {
        "1": "string[1:3] + string[-3:]",
        "2": "string[:3] + string[-3:-1]",
        "3": "string[0:3] + string[-3:]",
        "4": "string[0:] + string[:-1]"
      },
      "answer": 3,
      "comment": "파이썬 슬라이스<br>[:] 처음부터 끝까지<br>[start:] start오프셋부터 끝까지<br>[:end] 처음부터 end-1 오프셋까지<br>[start : end] start오프셋부터 end-1 오프셋까지<br>[start : end : step] step만큼 문자를 건너뛰면서, 위와 동일"
    }, {
      "num": 76,
      "subject": 4,
      "ask": "파이썬의 변수 작성 규칙 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "첫 자리에 숫자를 사용할 수 없다.",
        "2": "영문 대문자/소문자, 숫자, 밑줄(_)의 사용이 가능하다.",
        "3": "변수 이름의 중간에 공백을 사용할 수 있다.",
        "4": "이미 사용되고 있는 예약어는 사용할 수 없다."
      },
      "answer": 3,
      "comment": "밑줄(_)사용은 가능하지만, 공백은 사용할 수 없습니다."
    }, {
      "num": 77,
      "subject": 4,
      "ask": "어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우이며, 하위 모듈에서 상위 모듈로 제어신호가 이동하여 상위 모듈에게 처리 명령을 부여하는 권리 전도현상이 발생하게 되는 결합도는?",
      "desc": "",
      "choice": {
        "1": "data coupling",
        "2": "stamp coupling",
        "3": "control coupling",
        "4": "common coupling"
      },
      "answer": 3,
      "comment": "제어하기 위한 목적 / 권리 전도현상 : 제어 결합도 control coupling"
    }, {
      "num": 78,
      "subject": 4,
      "ask": "다음 C 프로그램의 결과 값은?",
      "desc": "main(void){<br>int i;<br>int sum = 0;<br>for(i = 1; i &lt;= 10; i=i+2)<br>&nbsp;&nbsp;&nbsp;&nbsp;sum = sum + i;<br>printf('%d', sum)<br>}",
      "choice": {
        "1": "15",
        "2": "19",
        "3": "25",
        "4": "27"
      },
      "answer": 3,
      "comment": "i sum<br>1 1<br>3 4<br>5 9<br>7 16<br>9 25<br>11 36 X ( i<=10; 때문에 적용 안됨)"
    }, {
      "num": 79,
      "subject": 4,
      "ask": "UNIX에서 새로운 프로세스를 생성하는 명령어는?",
      "desc": "",
      "choice": {
        "1": "is",
        "2": "cat",
        "3": "fork",
        "4": "chmod"
      },
      "answer": 3,
      "comment": "ls - 디렉토리나 파일목록 출력<br>cat - 파일 내용 출력<br>chmod - 파일이나 디렉토리에 대한 접근권한 변경"
    }, {
      "num": 80,
      "subject": 4,
      "ask": "C언어에서 정수 자료형으로 옳은 것은?",
      "desc": "",
      "choice": {
        "1": "int",
        "2": "float",
        "3": "char",
        "4": "double"
      },
      "answer": 1,
      "comment": "int: 정수<br>char : 문자<br>float / double : 실수"
    }, {
      "num": 81,
      "subject": 5,
      "ask": "물리적인 사물과 컴퓨터에 동일하게 표현되는 가상의 모델로 실제 물리적인 자산 대신 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있고, 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있는 모델은?",
      "desc": "",
      "choice": {
        "1": "최적화",
        "2": "실행 시간",
        "3": "디지털 트윈",
        "4": "N-Screen"
      },
      "answer": 3,
      "comment": "디지털 트윈(digital twin)은 미국 제너럴 일렉영(GE)이 주창한 개념으로, 컴퓨터에 현실 속 사물의 쌍둥이를 가상화하여 만들고, 현실에서 발생할 수 있는 상황을 컴퓨터로 시뮬레이션함으로써 결과를 미리 예측하는 기술입니다."
    }, {
      "num": 82,
      "subject": 5,
      "ask": "정보보안의 3대 요소에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "기밀성",
        "2": "휘발성",
        "3": "무결성",
        "4": "가용성"
      },
      "answer": 2,
      "comment": "정보보안 3대 요소 : 기밀성, 무결성, 가용성"
    }, {
      "num": 83,
      "subject": 5,
      "ask": "다음 빈칸에 알맞은 기술은",
      "desc": "( )은/는 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술이다.",
      "choice": {
        "1": "Quantum Key Distribution",
        "2": "Digital Rights Management",
        "3": "Grayware",
        "4": "Mashup"
      },
      "answer": 4,
      "comment": "Quantum Key Distribution -- 양자암호관련된거<br>Digital Rights Management -- DRM이라고도 하며, 저작권관리 관련 기술<br>Grayware -- 바이러스, 트로잔등 악성프로그램과는 다르게 사용자 동의를 받아 설치하는 프로그램"
    }, {
      "num": 84,
      "subject": 5,
      "ask": "기능점수(Functional Point)모형에서 비용산정에 이용되는 요소가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "클래스 인터페이스",
        "2": "명령어(사용자 질의수)",
        "3": "데이터파일",
        "4": "출력보고서"
      },
      "answer": 1,
      "comment": "FP 기능별 가중치 산정요소<br>자료 입력(입력 양식)<br>정보 출력(출력 보고서)<br>명령어(사용자 질의수)<br>데이터 파일<br>필요한 외부 루틴과의 인터페이스"
    }, {
      "num": 85,
      "subject": 5,
      "ask": "블록 암호화 방식이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "DES",
        "2": "RC4",
        "3": "AES",
        "4": "SEED"
      },
      "answer": 2,
      "comment": "블록 암호화 방식: DES, RC5, AES, SEED, IDEA 따라서 RC4가 아니라 RC5이어야 함"
    }, {
      "num": 86,
      "subject": 5,
      "ask": "Putnam 모형을 기초로 해서 만든 자동화 추정 도구는?",
      "desc": "",
      "choice": {
        "1": "SQLR/30",
        "2": "SLIM",
        "3": "MESH",
        "4": "NFV"
      },
      "answer": 2,
      "comment": "SLIM : Putnam 기법 모형을 기초로 개발된 자동화 추정 도구"
    }, {
      "num": 87,
      "subject": 5,
      "ask": "큰 숫자를 소인수 분해하기 어렵다는 기반 하에 1978년 MIT에 의해 제안된 공개키 암호화 알고리즘은?",
      "desc": "",
      "choice": {
        "1": "DES",
        "2": "ARIA",
        "3": "SEED",
        "4": "RSA"
      },
      "answer": 4,
      "comment": "1. DES는 1975년 IBM에서 개발함<br>2. ARIA는 국내에서 개발됨(SEED 이후 만들어짐)<br>3. SEED도 국내에서 개발됨"
    }, {
      "num": 88,
      "subject": 5,
      "ask": "COCOMO 모델의 프로젝트 유형으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "Organic",
        "2": "Semi-detached",
        "3": "Embedded",
        "4": "Sequentail"
      },
      "answer": 4,
      "comment": "조직형 / 반분리형 / 내장형<br>organic(5만라인) / semi-detached(30만라인이하) / Embedded(30만라인이상)"
    }, {
      "num": 89,
      "subject": 5,
      "ask": "빅데이터 분석 기술 중 대량의 데이터를 분석하여 데이터 속에 내재되어 있는 변수 사이의 상호관례를 규명하여 일정한 패턴을 찾아내는 기법은?",
      "desc": "",
      "choice": {
        "1": "Data Mining",
        "2": "Wm-Bus",
        "3": "Digital Twin",
        "4": "Zigbee"
      },
      "answer": 1,
      "comment": "Wm-Bus:무선 미터버스, 산업용 무선 프로토콜<br>Digital Twin:컴퓨터 시뮬레이션(가상화)을 통해 결과를 예측하는 기술<br>Zigbee:직비, 무선 메시 네트워크의 표준(저가, 저전력)"
    }, {
      "num": 90,
      "subject": 5,
      "ask": "기존 무선 랜의 한계 극복을 위해 등장하였으며, 대규모 디바이스의 네트워크 생성에 최적화되어 차세대 이동통신, 홈네트워킹, 공공 안전 등의 특수목적을 위한 새로운 방식의 네트워크 기술을 의미하는 것은?",
      "desc": "",
      "choice": {
        "1": "Software Defined Perimeter",
        "2": "Virtual Private Network",
        "3": "Local Area Network",
        "4": "Mesh Network"
      },
      "answer": 4,
      "comment": "Software Defined Perimeter:소프트웨어 정의 경계<br>Virtual Private Network:가상 사설망<br>Local Area Network:근거리 통신망"
    }, {
      "num": 91,
      "subject": 5,
      "ask": "DDoS 공격과 연관이 있는 공격 방법은?",
      "desc": "",
      "choice": {
        "1": "Secure shell",
        "2": "Tribe Flood Network",
        "3": "Nimda",
        "4": "Deadlock"
      },
      "answer": 2,
      "comment": "DDoS는 네트워크 취약점이 있는 호스트들을 탐색한 후 이를 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트(agent)로 만든 후 DDoS공격에 이용"
    }, {
      "num": 92,
      "subject": 5,
      "ask": "CPM 네트워크가 다음과 같을 때 임계경로의 소요기일은?",
      "desc": "<img src='../assets/img/quizImg/202003_92.png' alt='이미지'>",
      "choice": {
        "1": "10일",
        "2": "12일",
        "3": "14일",
        "4": "16일"
      },
      "answer": 3,
      "comment": "임계 경로 : 작업의 시작 및 종료 구간이 동시에 이루어질 때 가장 오래 걸리는 경로를 임계 경로라고 한다."
    }, {
      "num": 93,
      "subject": 5,
      "ask": "RIP(Routing Information Protocol)에 대한 설명으로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "거리 벡터 라우팅 프로토콜이라고도 한다.",
        "2": "소규모 네트워크 환경에 적합하다.",
        "3": "최대 홉 카운트를 115홉 이하로 한정하고 있다.",
        "4": "최단경로탐색에는 Bellman-Ford 알고리즘을 사용한다."
      },
      "answer": 3,
      "comment": "RIP의 최대 홉 카운트는 15이다."
    }, {
      "num": 94,
      "subject": 5,
      "ask": "소프트웨어 생명주기 모형 중 고전적 생명주기 모형으로 선형 순차적 모델이라고도 하며, 타당성 검토, 계획, 요구사항 분석, 구현, 테스트, 유지보수의 단계를 통해 소프트웨어를 개발하는 모형은?",
      "desc": "",
      "choice": {
        "1": "폭포수 모형",
        "2": "애자일 모형",
        "3": "컴포넌트 기반 방법론",
        "4": "6GT 모형"
      },
      "answer": 1,
      "comment": "폭포수 모형 : 타당성 검토 -&gt; 계획 -&gt; 요구사항분석 -&gt; 구현 -&gt; 테스트 - &gt;유지보수 단계"
    }, {
      "num": 95,
      "subject": 5,
      "ask": "소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동이 순서대로 나열된 것은?",
      "desc": "Ⓐ 계획 수립 Ⓑ 고객평가<br>Ⓒ 개발 및 검증<br>Ⓓ 위험 분석",
      "choice": {
        "1": "Ⓐ-Ⓑ-Ⓓ-Ⓒ 순으로 반복",
        "2": "Ⓐ-Ⓓ-Ⓒ-Ⓑ 순으로 반복",
        "3": "Ⓐ-Ⓑ-Ⓒ-Ⓓ 순으로 반복",
        "4": "Ⓐ-Ⓒ-Ⓑ-Ⓓ 순으로 반복"
      },
      "answer": 2,
      "comment": "나선형모델 4가지 활동 순서<br>계획 수립 - 위험 분석 - 개발 및 검증 - 고객평가"
    }, {
      "num": 96,
      "subject": 5,
      "ask": "전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추는 방법으로 소프트웨어를 완성시키는 재사용 방법은?",
      "desc": "",
      "choice": {
        "1": "합성 중심",
        "2": "생성 중심",
        "3": "분리 중심",
        "4": "구조 중심"
      },
      "answer": 1,
      "comment": "합성 중심(Composition-Based) : 전자 칩과 같은 소프트웨어 부품, 즉 블록(모듈)을 만들어서 끼워 맞추어 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 한다.<br><br>생성 중심(Generation-Based) : 추상화 형태로 쓰여진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 한다."
    }, {
      "num": 97,
      "subject": 5,
      "ask": "다음 JAVA코드에서 밑줄로 표시된 부분에는 어떤 보안 약점이 존재하는가? (단, key는 암호화 키를 저장하는 변수이다.)",
      "desc": "<img src='../assets/img/quizImg/202003_97.png' alt='이미지'>",
      "choice": {
        "1": "무결성 검사 없는 코드 다운로드",
        "2": "중요 자원에 대한 잘못된 권한 설정",
        "3": "하드코드된 암호화 키 사용",
        "4": "적절한 인증없는 중요 기능 허용"
      },
      "answer": 3,
      "comment": "소스 코드 내부에 암호화 키를 상수 형태로 하드코딩하여 사용하면 악의적인 공격자에게 암호화 키가노출될 위협이 있다."
    }, {
      "num": 98,
      "subject": 5,
      "ask": "소프트웨어 개발 표준 중 소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준은?",
      "desc": "",
      "choice": {
        "1": "SCRUM",
        "2": "ISO/IEC 12509",
        "3": "SPICE",
        "4": "CASE"
      },
      "answer": 3,
      "comment": "소프트웨어 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준 = SPICE"
    }, {
      "num": 99,
      "subject": 5,
      "ask": "실무적으로 검증된 개발보안 방법론 중 하나로써 SW보안의 모범 사례를 SDLC(Software Development Life Cycle)에 통합한 소프트웨어 개발 보안 생명주기 방법론은?",
      "desc": "",
      "choice": {
        "1": "CLASP",
        "2": "CWE",
        "3": "PIMS",
        "4": "Seven Touchpoints"
      },
      "answer": 4,
      "comment": "1. CLASP - Comprehensive, Lightweight Application Security Process. 소프트웨어 개발 생명주기(SDLC) 초기단계에 보안강화를 목적으로 하는 정형화된 프로세스로써, 활동중심·역할기반의 프로세스로 구성된 집합체로, 이미 운영중인 시스템에 적용하기 적합합니다.<br>2. CWE - Common Weakness Enumeration. 주요 보안 취약점, 보안 문제를 정리하는 프로젝트입니다.<br>3. PIMS - Personal Information Management System. 개인정보 보호관리체계입니다.<br>4. Seven Touchpoints - 소프트웨어 개발 생명주기(SDLC)의 각 단계에 관련된 7가지의 보안 강화 활동을 개발자에게 집중적으로 관리하도록 요구하여 실무적으로 검증된 개발보안 방법론입니다."
    }, {
      "num": 100,
      "subject": 5,
      "ask": "다음 LAN의 네트워크 토폴로지는?",
      "desc": "<img src='../assets/img/quizImg/202003_100.png' alt='이미지'>",
      "choice": {
        "1": "버스형",
        "2": "성형",
        "3": "링형",
        "4": "그물형"
      },
      "answer": 1,
      "comment": "버스형 : 한 개의 통신 회선, 여러 대의 단말 장치<br>성형 : 중앙 집중형<br>링형 : point to point<br>그물형 ( = 망형 ) : 모든 지점의 컴퓨터와 단말장치가 서로 연결<br>계층형 ( = Tree ) : 중앙 컴퓨터 및 일정 지역 단말장치까지는 하나의 통신, 이웃하는 단말장치는 중간 단말장치"
    }]
  }, {
    "title": "2020년 1회,2회 통합 기출문제",
    "question": [{
      "num": 1,
      "subject": 3,
      "ask": "검토회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후 짧은 검토 회의를 통해 오류를 조기에 검출하는데 목적을 두는 요구 사항 검토 방법은?",
      "desc": "",
      "choice": {
        "1": "빌드 검증",
        "2": "동료 검토",
        "3": "워크 스루",
        "4": "개발자 검토"
      },
      "answer": 3,
      "comment": "2.동료검토: 2~3명이 진행하는 리뷰형태로 작성자가 설명하고 이해관계자들이 설명을 들으면서 결함을 발견하는 형태<br>3.워크스루: 검토자료를 회의전에 배포하여 사전 검토한 후, 짧은 시간 동안 회의를 진행하는 형태로 리뷰를 통해 오류를 조기에 검출하는데 목적은 둔 검증기법"
    }, {
      "num": 2,
      "subject": 3,
      "ask": "코드 설계에서 일정한 일련번호를 부여하는 방식의 코드는?",
      "desc": "",
      "choice": {
        "1": "연상 코드",
        "2": "블록 코드",
        "3": "순차 코드",
        "4": "표의 숫자 코드"
      },
      "answer": 3,
      "comment": "연상코드 : 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법<br><br>블록코드 : 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법 (=구분코드)<br><br>표의 숫자 코드 : 코드화 대상 항목의 성질, 물리적 수치를 그대로 코드에 적용시키는 방법 (=유효숫자코드)[해설작성자 : 와우갓띵]<br>1. 연상 코드: 항목의 명칭이나 약호와 관계 있는 숫자, 문자, 기호를 이용하여 코드를 부여하는 방법<br>2. 블록 코드: 대상 항목에서 공통적인 것을 블록으로 구분하고 블록 내에 일련 번호를 부여하는 방법<br>3. 순차 코드: 일정 기준에 따라 최초의 자료부터 일련번호를 부여하는 방법<br>4. 표의 숫자 코드: 길이 넓이 부피 등 항목의 성질의 물리적인 수치를 그대로 코드에 적용시키는 방법[해설작성자 : 합격현]<br><br>일련번호를 부여하는 코드는 순차 코드 뿐입니다 답변으로는 1번이라 되어있는데 연상 코드는 숫자뿐만 아니라 문자, 기호를 입력하기 때문에 답이 될수 없습니다.[해설작성자 : 준비생]"
    }, {
      "num": 3,
      "subject": 2,
      "ask": "객체지향 프로그램에서 데이터를 추상화하는 단위는?",
      "desc": "",
      "choice": {
        "1": "메소드",
        "2": "클래스",
        "3": "상속성",
        "4": "메시지"
      },
      "answer": 2,
      "comment": "메소드 : 객체의 행위상속성 : 객체의 데이터메시지 : 객체 간의 통신"
    }, {
      "num": 4,
      "subject": 4,
      "ask": "데이터 흐름도(DFD)의 구성요소에 포함되지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "process",
        "2": "data flow",
        "3": "data store",
        "4": "data dictionary"
      },
      "answer": 4,
      "comment": "데이터 흐름도(Data Flow Diagram) 구성요소에는<br>프로세스(Process), 자료 흐름(Flow), 자료 저장소(Data Store), 단말(Terminator)이 있다.<br>그러므로 답은 4.data dictionary(데이터 사전)"
    }, {
      "num": 5,
      "subject": 4,
      "ask": "소프트웨어 설계시 구축된 플랫폼의 성능특성 분석에 사용되는 측정 항목이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "응답시간(Response Time)",
        "2": "가용성(Availability)",
        "3": "사용률(Utilization)",
        "4": "서버 튜닝(Server Tuning)"
      },
      "answer": 4,
      "comment": "어플리케이션 성능 측정 항목은응답시간, 처리량, 자원 사용률, 경과 시간이다.그러므로 측정 항목이 아닌 것은 4.서버 튜닝(Server Tuning)"
    }, {
      "num": 6,
      "subject": 1,
      "ask": "UML 확장 모델에서 스테레오 타입 객체를 표현할 때 사용하는 기호로 맞는 것은?",
      "desc": "",
      "choice": {
        "1": "《 》",
        "2": "(( ))",
        "3": "{{ }}",
        "4": "[[ ]]"
      },
      "answer": 1,
      "comment": "UML 확장 모델스테레오 타입 객체 표현기호《 》"
    }, {
      "num": 7,
      "subject": 2,
      "ask": "GoF(Gang of Four)의 디자인 패턴에서 행위 패턴에 속하는 것은?❶❷❸❹",
      "desc": "",
      "choice": {
        "1": "Builder",
        "2": "Visitor",
        "3": "Prototype",
        "4": "Bridge"
      },
      "answer": 2,
      "comment": "생성패턴 : 객체의 생성과 관련된 패턴<br>구조패턴 : 클래스나 객체들을 조합하여 더 큰 구조로 만들 수 있게 해주는 패턴<br>행위패턴 : 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴<br>1. Builder : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성한다<br>2. Visitor : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성한다3. Prototype : 원본 객체를 복제하는 방법으로 객체를 생성한다.<br>4. Bridge : 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한다.<br>1.Builder - 생성패턴<br>3.Prototype - 생성패턴<br>4.Bridge - 구조패턴"
    }, {
      "num": 8,
      "subject": 4,
      "ask": "자료 사전에서 자료의 생략을 의미하는 기호는?",
      "desc": "",
      "choice": {
        "1": "{ }",
        "2": "**",
        "3": "=",
        "4": "(　)"
      },
      "answer": 4,
      "comment": "정의 =<br>구성,연결 +<br>반복 { }<br>주석 **<br>선택 [ㅣ]<br>생략 ( )"
    }, {
      "num": 9,
      "subject": 3,
      "ask": "트랜잭션이 올바르게 처리되고 있는지 데이터를 감시하고 제어하는 미들웨어는?",
      "desc": "",
      "choice": {
        "1": "RPC",
        "2": "ORB",
        "3": "TP monitor",
        "4": "HUB"
      },
      "answer": 3,
      "comment": "1.RPC: remote procedure call 원격 절차 호출 또는 원격 프로시저 호출.<br>2.ORB: object request broker, 객체 간 메시지 전달을 지원하는 미들웨어<br>3.TP monitor: 트랜잭션 처리를 감시/제어하는 미들웨어"
    }, {
      "num": 10,
      "subject": 2,
      "ask": "UI 설계 원칙에서 누구나 쉽게 이해하고 사용할 수 있어야 한다는 것은?",
      "desc": "",
      "choice": {
        "1": "유효성",
        "2": "직관성",
        "3": "무결성",
        "4": "유연성"
      },
      "answer": 2,
      "comment": "직관성 : 누구나 쉽게 이용하고 쉽게 사용할 수 있어야 함<br>유효성 : 정확하고 완벽하게 사용자의 목표가 달성될 수 있도록 제작<br>학습성 : 초보와 숙련자 모두가 쉽게 배우고 사용할 수 있게 제작<br>유연성 : 사용자의 인터랙션을 최대한 포용하고, 실수를 방지할 수 있도록 제작"
    }, {
      "num": 11,
      "subject": 3,
      "ask": "XP(eXtreme Programming)의 5가지 가치로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "용기",
        "2": "의사소통",
        "3": "정형분석",
        "4": "피드백"
      },
      "answer": 3,
      "comment": "XP(eXtreme Programming)의 5가지 가치<br>용기(Courage) : 고객의 요구사항 변화에 능동적인 대처<br>단순성(Simplicity) : 부가적 기능, 사용되지 않는 구조와 알고리즘 배제<br>커뮤니케이션(Communication) : 개발자, 관리자, 고객 간의 원활한 의사소통<br>피드백(Feedback) : 지속적인 테스트와 반복적 결함 수정, 빠른 피드백<br>존중(Respect) : 모든 프로젝트 관리자는 팀원의 기여를 존중"
    }, {
      "num": 12,
      "subject": 4,
      "ask": "UML 모델에서 사용하는 Structural Diagram 에 속하지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "Class Diagram",
        "2": "Object Diagram",
        "3": "Component Diagram",
        "4": "Activity Diagram"
      },
      "answer": 4,
      "comment": "Activity Diagram : 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다.<br>Activity Diagram은 Behavioral Diagram에 속한다."
    }, {
      "num": 13,
      "subject": 4,
      "ask": "소프트웨어 개발 방법 중 요구사항 분석(requirements annalysis)과 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "비용과 일정에 대한 제약설정",
        "2": "타당성 조사",
        "3": "요구사항 정의 문서화",
        "4": "설계 명세서 작성"
      },
      "answer": 4,
      "comment": "요구사항 분석 (requirements annalysis)<br>-비용과 일정에 대한 제약설정<br>-타당성 조사<br>-요구사항 정의 문서화<br>4. 설계명세서작성은 요구사항 분석 다음 단계인 요구사항 명세에서"
    }, {
      "num": 14,
      "subject": 1,
      "ask": "럼바우(Rumbaugh)의 객체지향 분석 절차를 가장 바르게 나열한 것은?",
      "desc": "",
      "choice": {
        "1": "객체 모형→동적 모형→기능 모형",
        "2": "객체 모형→기능 모형→동적 모형",
        "3": "기능 모형→동적 모형→객체 모형",
        "4": "기능 모형→객체 모형→동적 모형"
      },
      "answer": 1,
      "comment": "럼바우 객체지향 분석 절차<br>1.객체 모델링-객체 다이어그램(객체 관계)으로 표시<br>-가장 중요하며 선행되어야함<br>2.동적 모델링<br>-상태 다이어그램(상태도)를 이용해 시간의 흐름에 따른 객체들간의 제어흐름, 상호작용, 동작순서 등의 동적인 행위를 표현하는 모델링<br>3.기능 모델링<br>-자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료흐름을 중심으로 처리"
    }, {
      "num": 15,
      "subject": 2,
      "ask": "공통 모듈에 대한 명세 기법 중 해당 기능에 대해 일관되게 이해하고 한 가지로 해석될 수 있도록 작성하는 원칙은?",
      "desc": "",
      "choice": {
        "1": "상호작용성",
        "2": "명확성",
        "3": "독립성",
        "4": "내용성"
      },
      "answer": 2,
      "comment": "공통모듈이란<br>-전체 프로그램의 기능 중 특정기능을 처리할 수 있는 실행코드<br>-자체적으로 컴파일 가능, 다른 프로그램에서 재사용 가능<br>-여러 기능 및 프로그램에서 공통으로 사용할 수 있는 모듈(예-날짜 처리를 위한 유틸리티 모듈 등)<br>공통모듈 원칙<br>-정확성 : 해당 기능이 실제 시스템 구현시 필요한지 아닌지를 알 수 있도록 정확하게 작성<br>-명확성 : 해당 기능에 대해 일관되게 이해하고 한가지로 해석될 수 있도록 작성<br>-완전성 : 시스템이 구현될 때 필요하고 요구되는 모든 것을 기술<br>-일관성 : 공통 기능 간에 상호 충돌이 없도록 작성<br>-추적성 : 공통 기능에 대한 요구사항 출처와 관련 시스템 등의 유기적 관계에 대한 식별이 가능하도록 작성"
    }, {
      "num": 16,
      "subject": 4,
      "ask": "객체지향 기법에서 클래스들 사이의 ‘부분-전체(part-whole)' 관계 또는 ’부분(is-a-part-of)'의 관계로 설명되는 연관성을 나타내는 용어는?",
      "desc": "",
      "choice": {
        "1": "일반화",
        "2": "추상화",
        "3": "캡슐화",
        "4": "집단화"
      },
      "answer": 4,
      "comment": "집단화 is part of(part가 들어가면 집단화 생각) : 클래스 간의 구조적인 집약 관계 '클래스 A는 클래스 B와 클래스 C로 구성된다'<br>일반화 is a :클래스들 간의 개념적인 포함 관계'자식 클래스 A는 부모 클래스 B의 일종이다.'<br>캡슐화 : 속성 (데이터)과 메소드(연산) 을 하나로 묶어서 객체로 구성된다.<br>추상화 : 공통 성질을 추출하여 수퍼클래스로 구성한다.<br>또한 객체 중심의 안정된 모델을 구축 가능 하며 현실 세계를 자연스럽게 표현한다.<br>장점으로 분석의 초점이 명확해진다."
    }, {
      "num": 17,
      "subject": 3,
      "ask": "CASE가 갖고 있는 주요 기능이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "그래픽 지원",
        "2": "소프트웨어 생명주기 전 단계의 연결",
        "3": "언어번역",
        "4": "다양한 소프트웨어 개발 모형 지원"
      },
      "answer": 3,
      "comment": "[Case가 가지는 주요 기능]<br>Case란 소프트웨어 개발의 자동화<br>1.S/W의 생명주기 전(모든)단계의 연결<br>2.모델들 사이의 모순검사<br>3.오류검증<br>4.자료흐름도 등 다이어그램 작성<br>5.다양한 소프트웨어 개발 모형지원<br>6.시스템 문서화 및 명세화를 위한 그래픽 지원"
    }, {
      "num": 18,
      "subject": 3,
      "ask": "DBMS 분석시 고려사항으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "가용성",
        "2": "성능",
        "3": "네트워크 구성도",
        "4": "상호 호환성"
      },
      "answer": 3,
      "comment": "[DBMS분석시 고려사항]<br>1.무결성(가용성)<br>2.일관성(상호호환성)<br>3.회복<br>4.보안<br>5.효율성(성능)<br>6.데이터베이스 확장"
    }, {
      "num": 19,
      "subject": 1,
      "ask": "HIPO(Hierarchy Input Process Output)에 대한 설명으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "상향식 소프트웨어 개발을 위한 문서화 도구이다.",
        "2": "HIPO 차트 종류에는 가시적 도표, 총체적 도표, 세부적 도표가 있다.",
        "3": "기능과 자료의 의존 관계를 동시에 표현할 수 있다.",
        "4": "보기 쉽고 이해하기 쉽다."
      },
      "answer": 1,
      "comment": "상향식이 아니라 하향식 소프트웨어 개발입니다"
    }, {
      "num": 20,
      "subject": 1,
      "ask": "객체지향 분석 방법론 중 E-R 다이어그램을 사용하여 객체의 행위를 모델링하며, 객체식별, 구조 식별, 주체 정의, 속성 및 관계 정의, 서비스 정의 등의 과정으로 구성되는 것은?",
      "desc": "",
      "choice": {
        "1": "Coad와 Yourdon 방법",
        "2": "Booch 방법",
        "3": "Jacobson 방법",
        "4": "Wirfs-Brocks 방법"
      },
      "answer": 1,
      "comment": "객체지향 분석 방법론<br>E-R다이어그램 사용 객체 행위 모델링 및 객체 구조 식별 및 주체 속성 및 관계 서비스 정의<br>- Coad 와 Yourdon 방법클래스와 객체 식별 및 의미 관계 식별<br>- Booch 방법소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링/객체모델링 동적 모델링 기능 모델링<br>- 럼바우(Rumbaugh) 기법"
    }, {
      "num": 21,
      "subject": 4,
      "ask": "정렬된 N개의 데이터를 처리하는데 O(Nlog2N)의 시간이 소요되는 정렬 알고리즘은?",
      "desc": "",
      "choice": {
        "1": "선택정렬",
        "2": "삽입정렬",
        "3": "버블정렬",
        "4": "합병정렬"
      },
      "answer": 4,
      "comment": "선택정렬 : O(n^2)<br>삽입정렬 : O(n^2)<br>버블정렬 : O(n^2)<br>합병정렬 : O(Nlog2N)"
    }, {
      "num": 22,
      "subject": 1,
      "ask": "White Box Testing 에 대한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "Base Path Testing, Boundary Value Analysis가 대표적인 기법이다.",
        "2": "Source Code 의 모든 문장을 한번 이상 수행함으로서 진행된다.",
        "3": "모듈 안의 작동을 직접 관찰 할 수 있다.",
        "4": "산출물의 각 기능별로 적절한 프로그램의 제어구조에 따라 선택, 반복 등의 부분들을 수행함으로써 논리적 경로를 점검한다."
      },
      "answer": 1,
      "comment": "White Box Testing 종류 : Condition Testing, Loop Testing, Data Flow Testing<br>Black Box Testing 종류 : Equivalence Partitioning Testing, Boundary Value Testing,<br>Cause-Effect Graphing Testing, Error Guessing, Comparison Testing"
    }, {
      "num": 23,
      "subject": 4,
      "ask": "소프트웨어 품질 측정을 위해 개발자 관점에서 고려해야 할 항목으로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "정확성",
        "2": "무결성",
        "3": "사용성",
        "4": "간결성"
      },
      "answer": 4,
      "comment": "소프트웨어 품질측정 개발자 관점정확성, 신뢰성, 효율성, 무결성, 유연성, 이식성, 재사용성, 상호운용성"
    }, {
      "num": 24,
      "subject": 2,
      "ask": "인터페이스 구현 검증도구 중 아래에서 설명하는 것은?",
      "desc": "-서비스 호출, 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크<br>-각 테스트 대상 분산 환경에 데몬을 사용하여 테스트 대상 프로그램을 통해 테스트를 수행하고, 통합하여 자동화하는 검증 도구",
      "choice": {
        "1": "xUnit",
        "2": "STAF",
        "3": "FitNesse",
        "4": "RubyNode"
      },
      "answer": 2,
      "comment": "인터페이스 구현 검증 도구xUnit : Java, C++ 등 다양한 언어 지원하는 단위 테스트 프레임워크<br>STAF : 서비스 호출 및 컴포넌트 재사용 등 환경 지원하는 테스트 프레임워크<br>FitNesse : 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크<br>NTAF : FitNesse의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 네이버의 테스트 자동화 프레임워크이다.<br>Selenium : 다양한 브라우저 및 개발 언어 지원하는 웹 애플리케이션 테스트 프레임워크<br>Watir : Ruby를 사용하는 애플리케이션 테스트 프레임워크<br>Ruby : 인터프리터 방식의 객체지향 스크립트 언어"
    }, {
      "num": 25,
      "subject": 4,
      "ask": "EAI(Enterprise Application Integration)의 구축 유형으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "Point-to-Point",
        "2": "Hub&Spoke",
        "3": "Message Bus",
        "4": "Tree"
      },
      "answer": 4,
      "comment": "EAI 구축 유형 : 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달 연계 통합등 상호연동이 가능하게 해주는 솔루션<br>Point - to - Point : 가장 기본적인 애플리케이션 통합 방식 1:1로 연결<br>Hub &Spoke : 단일 접점인 허브 시스템을 통해 데이터 전송하는 중앙 집중형 방식<br>Message Bus : 애플리케이션 사이에 미들웨어를 두어 처리하는 방식<br>Hybrid : Hub &Spoke 와 Message Bus 혼합 방식"
    }, {
      "num": 26,
      "subject": 4,
      "ask": "다음 트리를 전위 순회(preorder traversal)한 결과는?",
      "desc": "<img src='../assets/img/quizImg/202006_img26.png' alt='이미지'>",
      "choice": {
        "1": "+*AB/*CDE",
        "2": "AB/C*D*E+",
        "3": "A/B*C*D+E",
        "4": "+**/ABCDE"
      },
      "answer": 4,
      "comment": "전위순회 : 루트를 먼저 방문 ex) +**/ABCDE<br>중위순회 : 왼쪽 하위트리를 방문한 뒤 루트를 방문 ex) A/B*C*D+E<br>후위순회 : 하위트리를 방문한 뒤 루트를 방문 ex) AB/C*D*E+"
    }, {
      "num": 27,
      "subject": 2,
      "ask": "인터페이스 보안을 위해 네트워크 영역에 적용될 수 있는 솔루션과 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "IPSec",
        "2": "SMTP",
        "3": "SSL",
        "4": "S-HTTP"
      },
      "answer": 2,
      "comment": "SMTP는 이메일 송/수신에 사용되는 프로토콜이다."
    }, {
      "num": 28,
      "subject": 3,
      "ask": "평가 점수에 따른 성적부여는 다음 표와 같다. 이를 구현한 소프트웨어를 경계값 분석 기법으로 테스트 하고자 할 때 다음 중 테스트 케이스의 입력 값으로 옳지 않은 것은?",
      "desc": "<img src='../assets/img/quizImg/202006_img28.png' alt='이미지'>",
      "choice": {
        "1": "59",
        "2": "80",
        "3": "90",
        "4": "90"
      },
      "answer": 3,
      "comment": "경계값 분석 기법 -> 경계가 되는 곳<br>0 59 60 79 80 10090은 80~100 사이 값이라서 테스트 의미가 없음<br>101이 되는 이유 : 100까지라서 그 이상의 값을 넣을 경우의 반응 확인 가능"
    }, {
      "num": 29,
      "subject": 1,
      "ask": "반정규화(Denormalization) 유형중 중복 테이블을 추가하는 방법에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "빌드 테이블의 추가",
        "2": "집계 테이블의 추가",
        "3": "진행 테이블의 추가",
        "4": "특정 부분만을 포함하는 테이블의 추가"
      },
      "answer": 1,
      "comment": "반 정규화 유형 중 중복 테이블 추가 방법진행 테이블 추가 / 집계 테이블 추가 / 특정 부분만을 포함하는 테이블 추가"
    }, {
      "num": 30,
      "subject": 1,
      "ask": "ISO/IEC 9126의 소프트웨어 품질 특성 중 기능성(Functionlity)의 하위 특성으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "학습성",
        "2": "적합성",
        "3": "정확성",
        "4": "보안성"
      },
      "answer": 1,
      "comment": "ISO/IEC 9126 의 기능성의 하위특성에는 적합성,정확성,상호 운용성,보안성,준수성 등이 있다"
    }, {
      "num": 31,
      "subject": 2,
      "ask": "다음 트리의 차수(degree)와 단말 노드(terminal node)의 수는?",
      "desc": "<img src='../assets/img/quizImg/202006_img31.png' alt='이미지'>",
      "choice": {
        "1": "차수: 4, 단말 노드: 4",
        "2": "차수: 2, 단말 노드: 4",
        "3": "차수: 4, 단말 노드: 8",
        "4": "차수: 2, 단말 노드: 8"
      },
      "answer": 2,
      "comment": "트리의 차수 : 전체 트리에서 가장 큰 차수 ex) A,C,E => 차수 2<br>말 노드 : 자식이 없는 노드 ex) D,G,H,F"
    }, {
      "num": 32,
      "subject": 4,
      "ask": "디지털 저작권 관리(DRM)의 기술 요소가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "크랙 방지 기술",
        "2": "정책 관리 기술",
        "3": "암호화 기술",
        "4": "방화벽 기술"
      },
      "answer": 4,
      "comment": "디지털 저작권 관리 (DRM)의 기술 요소<br>암호화 / 키 관리 / 암호화 파일 생성 / 식별 기술 / 저작권 표현 / 정책 관리 / 크랙 방지 / 인증"
    }, {
      "num": 33,
      "subject": 3,
      "ask": "소프트 웨어 테스트에서 오류의 80%는 전체 모듈의 20% 내에서 발견된다는 법칙은?",
      "desc": "",
      "choice": {
        "1": "Brooks의 법칙",
        "2": "Boehm의 법칙",
        "3": "Pareto의 법칙",
        "4": "Jackson의 법칙"
      },
      "answer": 3,
      "comment": "오류의 80%는 전체의 20%내에서 발견된다는 법칙 : 파레토 법칙<br>- 지연되는 프로젝트에 인력을 더 투입하면 오히려 더 늦어진다 : Brooks의 법칙<br>- 동일 테스트 케이스로 동일 테스트 반복 시 더 이상 결함이 발견되지 않은 현상 : 살충제 페러독스 Pesticide Paradox<br>- 결함을 모두 제거해도 사용자 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없다 : 오류 : 부재의 궤변Absence of Errors Fallacy<br>시험에 brooks랑 pareto만 나왔던걸로 기억(2015~2020기준)"
    }, {
      "num": 34,
      "subject": 2,
      "ask": "소프트웨어 형상 관리의 의미로 적절한 것은?",
      "desc": "",
      "choice": {
        "1": "비용에 관한 사항을 효율적으로 관리하는 것",
        "2": "개발 과정의 변경 사항을 관리하는 것",
        "3": "테스트 과정에서 소프트웨어를 통합하는 것",
        "4": "개발 인력을 관리하는 것"
      },
      "answer": 2,
      "comment": "소프트웨어 형상 관리 : 개발과정에서 소프트웨어의 변경사항을 관리하기 위해 개발된 일련의 활동."
    }, {
      "num": 35,
      "subject": 3,
      "ask": "알고리즘 시간복잡도 O(1)이 의미하는 것은?",
      "desc": "",
      "choice": {
        "1": "컴퓨터 처리가 불가",
        "2": "알고리즘 입력 데이터 수가 한 개",
        "3": "알고리즘 수행시간이 입력 데이터 수와 관계없이 일정",
        "4": "알고리즘 길이가 입력 데이터보다 작음"
      },
      "answer": 3,
      "comment": "알고리즘 시간 복잡도<br>비례하지 않는(항상 일정한) O(1)<br>로그에 비례하는 O(log2^n)<br>정비례하는(선형) O(n)<br>로그*변수에 비례하는(선형 로그) O(nlog2^n)<br>제곱에 비례하는 O(n^2)<br>세제곱에 비례하는 O(n^3)<br>지수 비례하는 O(2^n)<br>팩토리얼에 비례하는 O(n!)"
    }, {
      "num": 36,
      "subject": 3,
      "ask": "소스코드 품질분석 도구 중 정적분석 도구가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "pmd",
        "2": "cppcheck",
        "3": "valMeter",
        "4": "checkstyle"
      },
      "answer": 3,
      "comment": "정적 분석 도구<br>pmd :소스 코드에 대한 미사용 변수 최적화안된 코드 등 결함을 유발할 수 있는 코드 검사<br>cppcheck : C/C++ 코드에 대한 메모리 누수 오버플로우 등 분석<br>SonarQube : 중복 코드 복잡도 코딩 설계 등을 분석하는 소스 분석 통합 플랫폼<br>checkstyle : 자바 코드에 대해 소스코드 표준을 따르고 있는지 검사한다.<br>ccm : 다양한 언어의 코드 복잡도를 분석한다.<br>cobertura : 자바 언어의 소스코드 복잡도 분석 및 테스트 커버리지 측정동적 분석 도구<br>Avalanche : Valgrind 프레임워크 및 STP기반 / 프로그램 결함 및 취약점 분석<br>valgrind : 프로그램 내에 존재하는 메모리 및 쓰레드 결함 분석"
    }, {
      "num": 37,
      "subject": 3,
      "ask": "검증 검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행하는 기법이며, 일반적으로 통제된 환경에서 사용자와 개발자가 함께 확인하면서 수행되는 검사는?",
      "desc": "",
      "choice": {
        "1": "동치 분할 검사",
        "2": "형상 검사",
        "3": "알파 검사",
        "4": "베타 검사"
      },
      "answer": 3,
      "comment": "동치 분할 검사 : 입력 자료에 초점을 맞춰 케이스를 만들고 검사하는 방법 - 블랙박스 테스트 종류<br>알파 테스트 : 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법 - 인수 테스트 종류<br>베타 테스트 : 선정된 최종 사용자가 여러명의 사용자 앞에서 행하는 테스트 기법 - 인수 테스트 종류"
    }, {
      "num": 38,
      "subject": 1,
      "ask": "하향식 통합에 있어서 모듈 간의 통합 시험을 위해 일시적으로 필요한 조건만을 가지고 임시로 제공되는 시험용 모듈을 무엇이라고 하는가?",
      "desc": "",
      "choice": {
        "1": "Stub",
        "2": "Driver",
        "3": "Procedure",
        "4": "Function"
      },
      "answer": 1,
      "comment": "상향식 : Driver<br>하향식 : Stub"
    }, {
      "num": 39,
      "subject": 3,
      "ask": "SW 패키징 도구 활용 시 고려 사항과 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "패키징 시 사용자에게 배포되는 SW이므로 보안을 고려한다.",
        "2": "사용자 편의성을 위한 복합성 및 비효율성 문제를 고려한다.",
        "3": "보안상 단일 기종에서만 사용할 수 있도록 해야 한다.",
        "4": "제품 SW 종류에 적합한 암호화 알고리즘을 적용한다."
      },
      "answer": 3,
      "comment": "패키징 고려사항<br>- 사용자의 운영체제, CPU, 메모리 등에 필요한 최소 환경 정의<br>- UI는 편의성, 직관성을 고려해야하고 매뉴얼과 일치시켜 패키징<br>- 소프트웨어와 하드웨어가 함께 관리될 수 있도록 Managed Service 형태로 제공<br>- 암호화, 모듈화하여 배포(다양한 기종에서 사용이 가능해야함)"
    }, {
      "num": 40,
      "subject": 2,
      "ask": "외계인코드(Alien Code)에 대한 설명으로 옳은 것은?",
      "desc": "",
      "choice": {
        "1": "프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.",
        "2": "아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 프로그램을 의미한다.",
        "3": "오류가 없어 디버깅 과정이 필요 없는 프로그램을 의미한다.",
        "4": "사용자가 직접 작성한 프로그램을 의미한다."
      },
      "answer": 2,
      "comment": "프로그램의 로직이 복잡하여 이해하기 어려운 프로그램을 의미한다.<br>나쁜코드를 코드의 로직이 얽혀 스파게티 코드라고도 함."
    }, {
      "num": 41,
      "subject": 1,
      "ask": "SQL 의 분류 중 DDL에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "UPDATE",
        "2": "ALTER",
        "3": "DROP",
        "4": "CREATE"
      },
      "answer": 1,
      "comment": "DDL(데이터 정의어): CREATE, ALTER, DROP<br>DML(데이터 조작어): SELECT, INSERT, UPDATE, DELETE<br>DCL(데이터 제어어): GRANT, REVOKE"
    }, {
      "num": 42,
      "subject": 2,
      "ask": "다음 두 릴레이션에서 외래키로 사용된 것은? (단 밑줄 친 속성은 기본키이다.)",
      "desc": "",
      "choice": {
        "1": "수강번호",
        "2": "과목번호",
        "3": "학번",
        "4": "과목명"
      },
      "answer": 2,
      "comment": "외래키 - 타 릴레이션의 기본키를 참조하는 속성 or 속성들의 집합<br>수강쪽에 과목번호가 있거나 과목쪽에 수강번호가 있어야한다."
    }, {
      "num": 43,
      "subject": 2,
      "ask": "데이터 무결성 제약조건 중 “개체 무결성 제약”조건에 대한 설명으로 맞는 것은?",
      "desc": "",
      "choice": {
        "1": "릴레이션 내의 튜플들이 각 속성의 도메인에 지정된 값만을 가져야 한다.",
        "2": "기본키에 속해 있는 애트리뷰트는 널값이나 중복값을 가질 수 없다.",
        "3": "릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다.",
        "4": "외래키 값은 참조 릴레이션의 기본키 값과 동일해야 한다."
      },
      "answer": 2,
      "comment": "데이터 제약조건<br>개체 무결성 제약 조건 : 기본 키를 구성하는 어떤 속성도 Null값이나 중복값을 가질 수 없다.<br>도메인 무결성 제약 조건 : 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다.<br>참조 무결성 제약 조건 : 외래키의 값은 Null이거나 참조 릴레이션의 기본키 값과 동일해야 한다."
    }, {
      "num": 44,
      "subject": 4,
      "ask": "뷰(view)에 대한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "뷰는 CREATE 문을 사용하여 정의한다.",
        "2": "뷰는 데이터의 논리적 독립성을 제공한다.",
        "3": "뷰를 제거할 때에는 DROP 문을 사용한다.",
        "4": "뷰는 저장장치 내에 물리적으로 존재한다."
      },
      "answer": 4,
      "comment": "뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다.<br>저장장치 내에 물리적으로 존재하지 않지만 사용자에게는 있는 것처럼 간주된다."
    }, {
      "num": 45,
      "subject": 4,
      "ask": "다음 SQL 문의 실행 결과는?",
      "desc": "",
      "choice": {
        "1": "10,000",
        "2": "15,000",
        "3": "20,000",
        "4": "25,000"
      },
      "answer": 4,
      "comment": "SELECT 가격 FROM 도서가격 WHERE 책번호 = (SELECT 책번호 FROM 도서 WHERE 책명 = '자료구조');<br>도서가격 테이블에서 '자료구조'와 일치하는 책번호의 가격을 찾아서 출력한다.<br>자료구조의 책 번호는 222, 가격은 25,000이므로 답은 4번"
    }, {
      "num": 46,
      "subject": 1,
      "ask": "데이터베이스의 논리적 설계(logical design) 단계에서 수행하는 작업이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "레코드 집중의 분석 및 설계",
        "2": "논리적 데이터베이스 구조로 매핑(mapping)",
        "3": "트랜잭션 인터페이스 설계",
        "4": "스키마의 평가 및 정제"
      },
      "answer": 1,
      "comment": "데이터 베이스의 논리적 설계(데이터모델링)<br>-현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정<br>-개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화<br>-개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계(종속적인 논리 스키마)<br>-트랜잭션의 인터페이스 설계<br>-관계형 데이터베이스라면 테이블 설계<br>-특정목표 DBMS에 따른 스키마설계<br>-스키마의 평가 및 정제"
    }, {
      "num": 47,
      "subject": 1,
      "ask": "이행적 함수 종속 관계를 의미하는 것은?",
      "desc": "",
      "choice": {
        "1": "A→B이고 B→C 일 때, A→C를 만족하는 관계",
        "2": "A→B이고 B→C 일 때, C→A를 만족하는 관계",
        "3": "A→B이고 B→C 일 때, B→A를 만족하는 관계",
        "4": "A→B이고 B→C 일 때, C→B를 만족하는 관계"
      },
      "answer": 1,
      "comment": "3차 정규화 (3NF)의 조건이행적 함수 종속 관계를 제거해야한다.<br>이행적 함수 종속 관계는 A→B이고 B→C 일 때, A→C인 관계를 말한다."
    }, {
      "num": 48,
      "subject": 1,
      "ask": "하나의 애트리뷰트가 가질 수 있는 원자값들의 집합을 의미하는 것은?",
      "desc": "",
      "choice": {
        "1": "도메인",
        "2": "튜플",
        "3": "엔티티",
        "4": "다형성"
      },
      "answer": 1,
      "comment": "-관계 데이터 모델에서 데이터의 가장 작은 논리적 단위는 애트리뷰트 값이며, 이 값은 원자 값만을 허용한다.<br>-같은 타입의 모든 원자 값들의 집합을 그 애트리뷰트의 도메인이라고 한다.<br>-도메인은 같은 도메인의 값들끼리 비교가 허용된다.<br>-하나의 도메인에 대하여 둘 이상의 애트리뷰트가 정의될 수도 있다.<br>-한 릴레이션에서는 모든 애트리뷰트들의 이름이 반드시 달라야 한다."
    }, {
      "num": 49,
      "subject": 3,
      "ask": "STUDENT 테이블에 독일어과 학생 50명, 중국어과 학생 30명, 영어영문학과 학생 50명의 정보가 저장되어 있을 때, 다음 두 SQL문의 실행 결과 튜플 수는? (단, DEPT 컬럼은 학과명)",
      "desc": "ⓐSELECT DEPT FROM STUDENT<br>ⓑSELECT DISTINCT DEPT FROM STUDENT",
      "choice": {
        "1": "ⓐ 3, ⓑ 3",
        "2": "ⓐ 50, ⓑ 3",
        "3": "ⓐ 130, ⓑ 3",
        "4": "ⓐ 130, ⓑ 130"
      },
      "answer": 3,
      "comment": "단순 SELECT(조건검색)의 경우 전체테이블의 튜플을 검색하기 때문에 130건(=50+30+50)이 조회된다.<br>DISTINCT(중복제거)의 경우 동일한 튜플을 제거하고 검색하기 때문에 독일어과 1건, 중국어과 1건, 영어영문학과 1건으로 총 3건이 조회된다."
    }, {
      "num": 50,
      "subject": 1,
      "ask": "관계대수 연산에서 두 릴레이션이 공통으로 가지고 있는 속성을 이용하여 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산은?",
      "desc": "",
      "choice": {
        "1": "⨝",
        "2": "⊃",
        "3": "π",
        "4": "σ"
      },
      "answer": 1,
      "comment": "셀렉트(Select)σ 릴레이션에서 조건을 만족하는 <br> 튜플 반환프로젝트(Project)π 릴레이션에서 주어진 속성들의 <br> 값으로만 구성된 튜플 반환 <br> 조인(Join)⋈공통 속성을 이용해 두개의 릴레이션 튜플들을 <br> 연결해 만들어진 튜플 반환 <br> 디비전(Division)÷ [R%S] 릴레이션S의 모든 튜플과 <br> 관련있는 릴레이션R의 튜플 반환"
    }, {
      "num": 51,
      "subject": 4,
      "ask": "트랜잭션의 특성 중 다음 설명에 해당하는 것은?",
      "desc": "<img src='../assets/img/quizImg/202006_img51.png' alt='이미지'>",
      "choice": {
        "1": "Durability",
        "2": "Share",
        "3": "Consistency",
        "4": "Atomicity"
      },
      "answer": 4,
      "comment": "Durability 영속성 : 성공적으로 완료된 트랜잭션의 결과는 <br> 시스템이 고장나더라도 영구적으로 반영되어야 한다. <br> Consistency 일관성 : 트랜잭션이 그 실행을 성공적으로 <br> 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환한다.<br> .Atomicity 원자성 : 트랜잭션 연산은 데이터베이스에 모두 <br> 반영되든지 아니면 전혀 반영되지 않아야 한다. <br> Isolation 격리성 : 트랜잭션 실행 중 생성하는 연산의 <br> 중간 결과를 다른 트랜잭션이 접근 불가하다."
    }, {
      "num": 52,
      "subject": 1,
      "ask": "분산 데이터베이스 목표 중 “데이터베이스의 분산된 물리적 환경에서 특정 지역의 컴퓨터 시스템이나 네트워크에 장애가 발생해도 데이터 무결성이 보장된다”는 것과 관계있는 것은?",
      "desc": "",
      "choice": {
        "1": "장애 투명성",
        "2": "병행 투명성",
        "3": "위치 투명성",
        "4": "중복 투명성"
      },
      "answer": 1,
      "comment": "분산데이터베이스의 목표 <br> -위치투명성(Location Trasparency) 데이터 베이스의 실제 <br> 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭 <br> 만으로 엑세스할 수 있음 <br> -중복투명성(Replication Transparency) 데이터가 여러 곳에 <br> 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 <br> 것 처럼 사용 가능, 시스템은 자동으로 여러 자료에 대한 <br> 작업 수행<br> -병행투명성(Concurrency Transparency) 다수의 트랜잭션이 <br> 동시에 실현되더라도 그 결과는 영향을 받지 않음 <br> -장애투명성(Failure Transparency) 트랜잭션, DBMS, <br> 네트워크, 컴퓨터 장애에도 트랜잭션을 정확히 처리함."
    }, {
      "num": 53,
      "subject": 1,
      "ask": "데이터베이스 시스템에서 삽입, 갱신, 삭제 등의 이벤트가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL은?",
      "desc": "",
      "choice": {
        "1": "트리거(trigger)",
        "2": "무결성(integrity)",
        "3": "잠금(lock)",
        "4": "복귀(rollback)"
      },
      "answer": 1,
      "comment": "트리거 : 데이터페이스가 미리 정해 놓은 조건이 충족되거나, <br> 특정테이블에 삽입, 수정, 삭제 등의 데이터 변경 이벤트가 <br> 발생하면 DBMS 에서 자동적으로 실행되도록 구현한 프로그램"
    }, {
      "num": 54,
      "subject": 2,
      "ask": "참조 무결성을 유지하기 위하여 DROP문에서 부모 테이블의 항목 값을 삭제할 경우 자동적으로 자식 테이블의 해당 레코드를 삭제하기 위한 옵션은?",
      "desc": "",
      "choice": {
        "1": "CLUSTER",
        "2": "CASCADE",
        "3": "SET-NULL",
        "4": "RESTRICTED"
      },
      "answer": 2,
      "comment": "DDL : <br> PRIMARY KEY : 기본키 정의 / FOREIGN KEY : 외래키 정의 <br> UNIQUE : 지정 속성은 중복값 가질 수 없음 / <br> NO ACTION : 변화가 있어도 조취를 취하지 않음 <br> CASCADE : 참조 테이블 튜플 삭제 시 관련 튜플 모두 삭제 <br> 및 속성 변경 시 속성값 모두 변경 <br> RESTRICTED : 타 개체가 제거할 요소를 참조중이면 <br> 제거를 취소<br> SET NULL : 참조 테이블 변화 시 기본 테이플 관련 속성값 <br> Null로 변경 <br> SET DEFAULT : 참조 테이블 변화 시 기본테이블의 관련 <br> 튜플 속성값을 기본값으로 변경 <br> CONSTRAINT : 제약 조건 이름 지정 / CHECK 속성값에 <br> 대한 제약 조건 정의 <br> <br> DML : <br> INSERT INTO ~ VELUES : 튜플 삽입 / DELETE FROM~ <br> WHERE : 튜플 삭제 <br> UPDATE ~ SET ~ WHERE : 튜플 내용 변경 / <br> SELECT~FROM~WHERE : 튜플 검색 <br> DISTINCT : 중복 튜플 발견 시 그 중 첫번째 하나만 검색 <br> DISTINCTROW : 중복 튜플 제거 및 하나만 검색 <br> (튜플 전체를 대상으로 검색) <br> PREDICATE : 검색할 튜플 수 제한 / AS 속성명 정의 <br> ORDER BY : 특정 속성 기준으로 정렬 후 검색할 때 <br> ASC : 오름차순 / DESC : 내림차순 / 생략 시 오름차순 <br> GROUP BY : 특정 속성 기준 그룹화하여 검색할 때 사용 <br> having절과 같이 사용되어야함"
    }, {
      "num": 55,
      "subject": 3,
      "ask": "DML에 해당하는 SQL 명령으로만 나열된 것은?",
      "desc": "",
      "choice": {
        "1": "DELETE, UPDATE, CREATE, ALTER",
        "2": "INSERT, DELETE, UPDATE, DROP",
        "3": "SELECT, INSERT, DELETE, UPDATE",
        "4": "SELECT, INSERT, DELETE, ALTER"
      },
      "answer": 3,
      "comment": "DML(Data Manipulation Language) 데이터 조작어 <br> DML의 유형에는 SELECT, INSERT, DELETE, UPDATE <br> 가 있다. <br> SELECT 데이터 조회 : 튜플 중 전체 또는 조건을 만족하는 <br> 튜플을 검색하여 주기억장치 상에 임시테이블로 구성 <br> INSERT 데이터 생성 : 새로운 튜플을 삽입할 때 사용하는 <br> 명령문 <br> DELETE 데이터 삭제 : 튜플들 중에서 특정 튜플을 삭제할 때 <br> 사용하는 명령문 <br> UPDATE 데이터 변경 : 특정 튜플의 내용을 변경할 때 <br> 사용하는 명령문"
    }, {
      "num": 56,
      "subject": 2,
      "ask": "데이터 제어언어(DCL)의 기능으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "데이터 보안",
        "2": "논리적, 물리적 데이터 구조 정의",
        "3": "무결성 유지",
        "4": "병행수행 제어"
      },
      "answer": 2,
      "comment": "DCL 데이터 제어 언어는 데이터 베이스 관리자가 데이터 <br> 보안, 무결성 유지, 병행 제어, 회복을 하기 위해 DBA가 <br> 사용하는 제어용 언어"
    }, {
      "num": 57,
      "subject": 2,
      "ask": "병행제어의 로킹(Locking) 단위에 대한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "데이터베이스, 파일, 레코드 등은 로킹 단위가 될 수 있다.",
        "2": "로킹 단위가 작아지면 로킹 오버헤드가 감소한다.",
        "3": "로킹 단위가 작아지면 데이터베이스 공유도가 증가한다.",
        "4": "한꺼번에 로킹 할 수 있는 객체의 크기를 로킹 단위라고 한다."
      },
      "answer": 2,
      "comment": "로킹단위↑ : 로크 수↓, 병행성↓, 오버헤드↓, 공유도↓, <br> 제어기법 간단하여 관리 수월 <br> 로킹단위↓ : 로크 수↑, 병행성↑, 오버헤드↑, 공유도↑, <br> 제어기법 까다로워 관리 복잡해설"
    }, {
      "num": 58,
      "subject": 3,
      "ask": "E-R 모델의 표현 방법으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "개체타입: 사각형",
        "2": "관계타입: 마름모",
        "3": "속성: 오각형",
        "4": "연결: 선"
      },
      "answer": 3,
      "comment": "개체 타입 (사각형) <br> 관계 타입 (마름모) <br> 속성 타입 (타원) <br> 연결 (선)"
    }, {
      "num": 59,
      "subject": 2,
      "ask": "다음 설명의 ( )안에 들어갈 내용으로 적합한 것은?",
      "desc": "<img src='../assets/img/quizImg/202006_img59.png' alt='이미지'>",
      "choice": {
        "1": "중복성",
        "2": "최소성",
        "3": "참조성",
        "4": "동일성"
      },
      "answer": 2,
      "comment": "후보키는 유일성 O 최소성 O <br> + 슈퍼키는 유일성 O 최소성 X <br> 키를 묻는 문제도 나왔었음(2015~2020)"
    }, {
      "num": 60,
      "subject": 4,
      "ask": "정규화 과정 중 1NF에서 2NF가 되기 위한 조건은?",
      "desc": "",
      "choice": {
        "1": "1NF를 만족하는 모든 도메인이 원자 값이어야 한다.",
        "2": "1NF를 만족하고 키가 아닌 모든 애트리뷰트들이 기본  키에 이행적으로 함수 종속되지 않아야 한다.",
        "3": "1NF를 만족하고 다치 종속이 제거되어야 한다.",
        "4": "1NF를 만족하고 키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속 관계를 만족해야 한다."
      },
      "answer": 4,
      "comment": "1NF 조건 : 원자값으로 구성 <br> 2NF 조건 : 부분 함수 종속 제거 (완전 함수적 종속 관계) <br> 3NF 조건 : 이행 함수 종속 제거BCNF 조건 : 결정자 함수 종속 <br> 4NF 조건 : 다중값(다치) 종속성 제거 <br> 5NF 조건 : 조인 종속성 제거"
    }, {
      "num": 61,
      "subject": 3,
      "ask": "IPv6에 대한 설명으로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "128비트의 주소 공간을 제공한다.",
        "2": "인증 및 보안 기능을 포함하고 있다.",
        "3": "패킷 크기가 64Kbyte로 고정되어 있다.",
        "4": "IPv6 확장 헤더를 통해 네트워크 기능 확장이 용이하다."
      },
      "answer": 3,
      "comment": "IPv6의 패킷 크기는 임의로 큰 크기의 패킷을 주고 받을 <br> 수 있다. <br> IPv4의 패킷 크기가 64Kbyte로 제한되어있다."
    }, {
      "num": 62,
      "subject": 2,
      "ask": "C언어에서 비트 논리연산자에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "^",
        "2": "?",
        "3": "&",
        "4": "~"
      },
      "answer": 2,
      "comment": "C언어에서 비트 논리 연산 : &, ^ , | , ~ , &lt;&lt;,&gt;&gt;  <br> ? 는 조건연산자"
    }, {
      "num": 63,
      "subject": 4,
      "ask": "TCP/IP 프로토콜 중 전송계층 프로토콜은?",
      "desc": "",
      "choice": {
        "1": "HTTP",
        "2": "SMTP",
        "3": "FTP",
        "4": "TCP"
      },
      "answer": 4,
      "comment": "HTTP/FTP/SMTP : OSI7계층 중 7층인 응용계층에서 동작 <br> TCP : OSI7계층 중 4층인 전송계층에서 동작 <br> (인터넷4계층에서도 3계층 전송계층 = 동일 층) <br> HTTP(Hyper Text Transfer Protocol) <br> FTP(File Transfer Protocol) <br> SMTP(Simple Mail Transfer Protocol) <br> TCP(Transmission Control Protocol) : 단어 그 자체로도 <br> 전송계층에서 동작하는 프로토콜임을 알 수 있다."
    }, {
      "num": 64,
      "subject": 3,
      "ask": "시스템에서 모듈 사이의 결합도(Coupling)에 대한 설명으로 옳은 것은?",
      "desc": "",
      "choice": {
        "1": "한 모듈 내에 있는 처리요소들 사이의 기능적인 연관 정도를 나타낸다.",
        "2": "결합도가 높으면 시스템 구현 및 유지보수 작업이 쉽다.",
        "3": "모듈간의 결합도를 약하게 하면 모듈 독립성이 향상된다.",
        "4": "자료결합도는 내용결합도 보다 결합도가 높다."
      },
      "answer": 3,
      "comment": "모듈 간의 결합도를 약하게 하면 모듈 독립성이 향상된다. <br> (결합도와 응집도 반비례라고 생각하면 편함 결합이 <br> 약하다 -> 응집이 강하다 -> 모듈 독립성이 향상된다."
    }, {
      "num": 65,
      "subject": 1,
      "ask": "은행가 알고리즘(Banker's Algorithm)은 교착상태의 해결 방법 중 어떤 기법에 해당하는가?",
      "desc": "",
      "choice": {
        "1": "Avoidance",
        "2": "Detection",
        "3": "Prevention",
        "4": "Recovery"
      },
      "answer": 1,
      "comment": "은행가 알고리즘은 교착상태의 해결 방법중 회피 기법이다."
    }, {
      "num": 66,
      "subject": 4,
      "ask": "UNIX의 쉘(Shell)에 관한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "명령어 해석기이다.",
        "2": "시스템과 사용자 간의 인터페이스를 담당한다.",
        "3": "여러 종류의 쉘이 있다.",
        "4": "프로세스, 기억장치, 입출력 관리를 수행한다."
      },
      "answer": 4,
      "comment": "-쉘(Shell) : 사용자의 명령어를 인식하여 프로그램을 호출하고 <br> 명령을 수행하는 명령어 해석기이다. 주기억장치에 상주하지 <br> 않고 명령어가 포함된 파일 형태로 존재하며 보조 기억 <br> 장치에서 교체 처리가 가능하다..공용 Shell(Bourne shell, <br> C shell, Korn shell)이나 사용자 자신이 만든 Shell을 사용할 수 <br> 있다. <br> <br> -커널(Kernel) : UNIX의 가장 핵심적인 부분. 컴퓨터 부팅시 <br> 주기억장치에 적재된 후 상주하며 실행된다. 하드웨어를 보호 <br> 하고 프로그램과 하드웨어 간의 인터페이스 역할을 한다."
    }, {
      "num": 67,
      "subject": 4,
      "ask": "교착 상태 발생의 필요 충분 조건이 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "상호 배제(mutual exclusion)",
        "2": "점유와 대기(hold and wait)",
        "3": "환형 대기(circular wait)",
        "4": "선점(preemption)"
      },
      "answer": 4,
      "comment": "교착상태 발생의 필요 충분 조건은 <br> 상호 배제, 점유와 대기, 환형 대기 , 비선점입니다."
    }, {
      "num": 68,
      "subject": 1,
      "ask": "OSI-7계층에서 종단간 신뢰성 있고 효율적인 데이터를 전송하기 위해 오류검출과 복구, 흐름 제어를 수행하는 계층은?",
      "desc": "",
      "choice": {
        "1": "전송 계층",
        "2": "세션 계층",
        "3": "표현 계층",
        "4": "응용 계층"
      },
      "answer": 1,
      "comment": "응용계층 - 사용자가 OSI환경에 접근할 수 있도록 서비스 제공표현계층 <br> - 응용계층으로 받은 데이터를 세션계층에 보내기 <br> 전에 통신에 적당한 형태로 변환, 세션계층에서 받은 데이터는 <br> 응용계층에 맞게 변환하는 기능 <br> 세션계층 - 송 수신 측 간의 관련성을 유지하고 대화 제어를 <br> 담당한다. <br> 전송계층 - 논리적 안정 및 균일한 데이터 전송 서비스를 <br> 제공함으로서 종단 시스템간 투명한 데이터 전송 가능 <br> 네트워크 - 개방 시스템들 간의 네트워크 연결을 관리 및 <br> 데이터 교환 및 중계 <br> 데이터링크 - 두 개의 인접한 개방 시스템들 간 신뢰성있고 <br> 효율적인 정보 전송 <br> 물리계층 - 전송에 필요한 두 장치 간의 실제 접속과 절단 등 <br> 기계적, 전기적 기능적 절차 특성에 대한 규칙"
    }, {
      "num": 69,
      "subject": 3,
      "ask": "IPv6의 주소체계로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "Unicast",
        "2": "Anycast",
        "3": "Broadcast",
        "4": "Multicast"
      },
      "answer": 3,
      "comment": "IPv6 : 유니캐스트(unicast) 멀티캐스트(multicast) <br> 애니캐스트(anycast) 세 가지 주소 체계 <br> IPv4가 애니캐스트 말고 브로드캐스트"
    }, {
      "num": 70,
      "subject": 2,
      "ask": "TCP/IP 네트워크에서 IP 주소를 MAC 주소로 변환하는 프로토콜은?",
      "desc": "",
      "choice": {
        "1": "UDP",
        "2": "ARP",
        "3": "TCP",
        "4": "ICMP"
      },
      "answer": 2,
      "comment": "UDP : 비연결형 서비스 제공 / 실시간 전송 네트워크에서 사용 <br> ARP : IP 주소를 MAC Address로 변환 (논리 주소 → 물리 주소) <br> TCP : 양방향 연결형 서비스 제공 / 가상 회선 연결 형태의 <br> 서비스 제공 / 스트릿 위주 패킷 전달 <br> ICMP : IP와 조합하여 통신 중에 발생하는 오류처리와 전송 <br> 경로 변경 등을 위한 제어 메시지를 관리 <br> IGMP : 멀티캐스트를 지원하는 호스트나 라우터 사이에서 <br> 멀티캐스트 그룹 유지를 위해 사용"
    }, {
      "num": 71,
      "subject": 3,
      "ask": "프로세스 상태의 종류가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "Ready",
        "2": "Running",
        "3": "Request",
        "4": "Exit"
      },
      "answer": 3,
      "comment": "프로세스의 상태 종류 <br>- 보류 (pending)<br>- 준비 (ready)<br>- 실행 (running)<br>- 대기 (blocked)<br>- 교착 (deadlock)<br>- 완료 (terminated)"
    }, {
      "num": 72,
      "subject": 1,
      "ask": "스레드(Thread)에 대한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "한 개의 프로세스는 여러 개의 스레드를 가질 수 없다.",
        "2": "커널 스레드의 경우 운영체제에 의해 스레드를 운용한다.",
        "3": "사용자 스레드의 경우 사용자가 만든 라이브러리를 사용하여 스레드를 운용한다.",
        "4": "스레드를 사용함으로써 하드웨어, 운영체제의 성능과 응용 프로그램의 처리율을 향상시킬 수 있다."
      },
      "answer": 1,
      "comment": "프로세스 내에서의 작업단위로 여러 자원을 할당받아 실행하는 <br> 프로그램 단위 <br> 한 개의 프로세스에는 하나 이상의 스레드가 존재 <br> 커널 스레드 : 운영체제 커널에 의해 스레드 운영 / <br> 구현 쉬움 / 속도 느림 <br> 사용자 스레드 : 사용자가 만든 라이브러리를 사용해 <br> 스레드 운용 / 속도 빠름 / 구현 어렵 <br> 하드웨어 운용체제 성능과 처리율을 향상 가능 <br> 응용프로그램 응답시간 단축 가능 <br> 실행 환경을 공유시켜 기억장소 낭비 줄어듬"
    }, {
      "num": 73,
      "subject": 4,
      "ask": "HRN(Highest Response-ratio Next) 스케줄링 방식에 대한 설명으로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "대기 시간이 긴 프로세스의 경우 우선 순위가 높아진다.",
        "2": "SJF 기법을 보완하기 위한 방식이다.",
        "3": "긴 작업과 짧은 작업 간의 지나친 불평등을 해소할 수 있다.",
        "4": "우선 순위를 계산하여 그 수치가 가장 낮은 것부터 높은 순으로 우선 순위가 부여된다."
      },
      "answer": 4,
      "comment": "HRN 스케줄링 방식 <br> - 비선점 스케줄링 <br> 실행시간이 긴 프로세스에 불리한 SJF 을 보완하기 위해 <br> 대기시간 및 서비스 시간을 이용, 우선순위를 계산 숫자가 <br> 높은것부터 낮은순으로 순위 부여 <br> 대기시간 + 서비스시간 / 서비스시간 = 우선순위값"
    }, {
      "num": 74,
      "subject": 4,
      "ask": "IEEE 802.11 워킹 그룹의 무선 LAN 표준화 현황 중 QoS 강화를 위해 MAC 지원 가능을 채택한 것은?",
      "desc": "",
      "choice": {
        "1": "802.11a",
        "2": "802.11b",
        "3": "802.11g",
        "4": "802.11e"
      },
      "answer": 4,
      "comment": "IEEE 802.11 워킹 그룹 무선 LAN 표준화 현황 중 QoS 강화 <br> MAC 지원 <br> IEEE 802.11a - 5GHz 대역의 전파를 사용하는 규격으로, <br> OFDM 기술을 사용해 최고 54Mbps까지의 전송 속도를 지원 <br> IEEE 802.11d - 지역 간 로밍용 확장 기술 <br> IEEE 802.11e - QoS, 패킷 버스팅 등 기능 확장 기술 <br> IEEE 802.11f - 인터 엑세스 포인트 프로토콜 <br> IEEE 802.11h - 유럽용 5GHz 대역 전송방식 <br> IEEE 802.11i - 보안 확장 <br> IEEE 802.11j - 일본용 전송 방식 <br> IEEE 802.11k - 전파 자원 측정 확장 기술 <br> IEEE 802.11p - 빠르게 움직이는 운송 수단을 위한 무선 접속 기술 <br> IEEE 802.11r - 빠른 로밍 <br> IEEE 802.11s - ESS 메쉬 네트워킹 <br> IEEE 802.11t - 무선 성능 예측 (WPP) <br> IEEE 802.11u - 802.11 기반이 아닌 네트워크와의 상호 연동 <br> IEEE 802.11v - 무선 네트워크 관리 <br> IEEE 802.11w - 보호된 관리 프레임"
    }, {
      "num": 75,
      "subject": 2,
      "ask": "C언어에서 사용할 수 없는 변수명은?",
      "desc": "",
      "choice": {
        "1": "student2019",
        "2": "text-color",
        "3": "_korea",
        "4": "amount"
      },
      "answer": 2,
      "comment": "영어 숫자 _ 사용가능 <br> 첫글자는 영어 or _ <br> 예약어 변수명으로 불가능 <br> 대소문자 구분"
    }, {
      "num": 76,
      "subject": 2,
      "ask": "스크립트 언어가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "PHP",
        "2": "Cobol",
        "3": "Basic",
        "4": "Python"
      },
      "answer": 2,
      "comment": "javascript <br> ASP <br> JSP <br> PHP <br> Python <br> basic"
    }, {
      "num": 77,
      "subject": 2,
      "ask": "다음의 페이지 참조 열(Page reference string)에 대해 페이지 교체 기법으로 선입선출 알고리즘을 사용할 경우 페이지 부재(Page Fault) 횟수는? (단, 할당된 페이지 프레임 수는 3이고, 처음에는 모든 프레임이 비어 있다.)",
      "desc": "<img src='../assets/img/quizImg/202006_img77.png' alt='이미지'>",
      "choice": {
        "1": "13",
        "2": "14",
        "3": "15",
        "4": "20"
      },
      "answer": 2,
      "comment": "7 <br> 70 <br> 701 <br> 201 <br> / <br> 231 <br> 230 <br> 430 <br> 420 <br> 423 <br> 023 <br> / <br> 013 <br> 012 <br> / <br> 712 <br> 702 <br> 총 14개 / 가장 오래있는 것 자리 교체"
    }, {
      "num": 78,
      "subject": 1,
      "ask": "C언어에서 배열 b[5]의 값은?",
      "desc": "<img src='../assets/img/quizImg/202006_img78.png' alt='이미지'>",
      "choice": {
        "1": "0",
        "2": "1",
        "3": "2",
        "4": "3"
      },
      "answer": 1,
      "comment": "9개의 방중 앞에 3개의 방에 각각 1,2,3의 값이 들어있고 나머지 6개의 방에는 0이 들어있다."
    }, {
      "num": 79,
      "subject": 4,
      "ask": "응집도가 가장 낮은 것은?",
      "desc": "",
      "choice": {
        "1": "기능적 응집도",
        "2": "시간적 응집도",
        "3": "절차적 응집도",
        "4": "우연적 응집도"
      },
      "answer": 4,
      "comment": "기능적(Functional cohesion) <br> 순차적(Sequential cohesion) <br> 교환적(Communication cohesion) <br> 절차적(Procedural cohesion) <br> 시간적(Temporal cohesion) <br> 논리적(Logical cohesion) <br> 우연적(Coincidental cohesion) <br> -&gt; 갈수록 응집도 약함"
    }, {
      "num": 80,
      "subject": 3,
      "ask": "JAVA 언어에서 접근제한자가 아닌 것은?",
      "desc": "",
      "choice": {
        "1": "public",
        "2": "protected",
        "3": "package",
        "4": "private"
      },
      "answer": 3,
      "comment": "JAVA 언어 접근 제한자 <br> public : 모든 접근 허용 <br> protected : 같은 패키지에 있는 객체와 상속관계 객체들만 허용 <br> default : 같은 패키지에 있는 객체들만 허용 <br> private : 현재 객체 내에서만 허용"
    }, {
      "num": 81,
      "subject": 1,
      "ask": "Rayleigh-Norden 곡선의 노력 분포도를 이용한 프로젝트 비용 산정기법은?",
      "desc": "",
      "choice": {
        "1": "Putnam 모형",
        "2": "델파이 모형",
        "3": "COCOMO 모형",
        "4": "기능점수 모형"
      },
      "answer": 1,
      "comment": "비용 산정 기법 <br> 전문가 감정 기법 : 조직 내에 있는 경험 많은 두 명 이상의 <br> 전문가에게 비용 산정을 의뢰하는 기법 <br> 델파이 기법 : 전문가 감정 기법의 주관적 편견을 보완하기 <br> 위해 많은 전문가의 의견을 종합 <br> LOC 기법 : 원시 코드 라인 수 기법으로서 원시 코드 라인 <br> 수의 비관치 낙관치 기대치를 측정하여 산정하는 기법 <br> 개발 단계별 인월수 기법 : LOC를 보완하기 위한 기법, <br> 필요 노력을 생명 주기의 각 단계별로 선정 <br> COCOMO : 보헴이 제안한 것으로 LOC에 의한 비용 산정 기법 <br> <br> 유형별 COCOMO <br> Organic : 조직형 / 소규모 소프트웨어 일괄 자료 처리 /5만 라인 이하 <br> Semi-detached : 반분리형 / 트랜잭션 처리 시스템이나 운영체제, <br> DB / 30만 라인 이하 <br> Embedded : 내장형 / 최대형 규모 트랜잭션 처리 시스템이나 <br> 운영체제 / 30만 라인 이상 <br> <br> COCOMO 종류 <br> Basic (기본): 소프트웨어 크기 및 개발 유형만 이용 <br> Intermediate(중간) : 기본형의 공식 토대로 사용하나 4가지  <br> 특성 및 15가지 요인에 의해 비용 산정 <br> 제품 특성 : 신뢰도 / DB크기 / 복잡도 <br> 컴퓨터 특성 : 수행시간제한 / 기억장소제한 / 가상 기계의 <br> 안정성 / Turn Around Time <br> 개발 요원의 특성 : 분석가 능력 / 개발 분야 경험 / 가상  <br> 기계 경험 / 프로그래머 능력 및 언어 경험 <br> 프로젝트 특성 : 소프트웨어 도구 이용 / 프로젝트 개발 일정 / <br> 최신 프로그래밍 기법 이용 <br> Detailed(발전) : 중간형 COCOMO 보완하여 만들어진 방법으로 <br> 개발 공정별보다 자세하고 정확하게 비용 산정 <br> Putnam 기법 : 소프트웨어 생명 주기의 전 과정 동안에 사용될 <br> 곡선의 노력의 분포를 가정해주는 모형 <br> Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다. <br> FP 기법 : 기능 점수 모형으로 알브레히트가 제안 / 요인별 <br> 가중치를 합산하여 총 기능 점수를 산출하여 점수와 영향도를 <br> 이용하여 비용 산정"
    }, {
      "num": 82,
      "subject": 4,
      "ask": "메모리상에서 프로그램의 복귀 주소와 변수사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우 오버플로우 상태로 가정하여 프로그램 실행을 중단하는 기술은?",
      "desc": "",
      "choice": {
        "1": "모드체크",
        "2": "리커버리 통제",
        "3": "시스로그",
        "4": "스택가드"
      },
      "answer": 4,
      "comment": "Stack Protection : Stack Overflow를 탐지하고 보안을 <br> 강화시키는 기법 <br> Stack Guard : Stack 상에 일정한 주소번지에 프로그램이 <br> 선언한 canary를 심어 두어, 스택의 변조 된 경우에, canary를 <br> 체크하여 프로그램이 비정상적으로 종료 시키는 기법 <br> Stack Shield : 함수의 리턴주소를 복사하여 실제 리턴주소를 <br> 참조하지 않고 함수를 리턴해주는 기법 <br> Syslog : 시스템에서 로그메시지를 처리하기 위해서 제공 <br> Recovery Control : 부적절한 사건/상황으로 인해 발생한 <br> 피해를 극복, 장애/혼란을 정돈하고 정상상태로 회복 <br> <br> + 카나리(Canary 또는 Canaries) : buffer와 SFP 사이에 <br> buffer overflow를 탐지하기 위한 특정 값(canary value)를 <br> 삽입하는 기법 <br> + Canary    종류 : terminator, random, random XOR <br> (스택가드는 canary 세 가지 모두를 지원) <br> + ProPolice 종류 : terminator와 random <br> + StackGuard와 ProPolice는 (함수 포인터들을 오버플로우하는) <br> 자동으로 할당된 구조체들에서 오버플로우를 방어하지 못한다."
    }, {
      "num": 83,
      "subject": 2,
      "ask": "백도어 탐지 방법으로 틀린 것은?",
      "desc": "",
      "choice": {
        "1": "무결성 검사",
        "2": "닫힌 포트 확인",
        "3": "로그 분석",
        "4": "SetUID 파일 검사"
      },
      "answer": 2,
      "comment": "백도어 탐지 방법 : 무결성 검사/로그 분석/SetUID 파일 검사/ <br> 열린 포트 검사/바이러스 및 백도어 탐지 툴 이용"
    }, {
      "num": 84,
      "subject": 4,
      "ask": "IP 또는 ICMP의 특성을 악용하여 특정 사이트에 집중적으로 데이터를 보내 네트워크 또는 시스템의 상태를 불능으로 만드는 공격 방법은?",
      "desc": "",
      "choice": {
        "1": "TearDrop",
        "2": "Smishing",
        "3": "Qshing",
        "4": "Smurfing"
      },
      "answer": 4,
      "comment": "서비스 공격 유형 <br> DoS (서비스 거부) : 표적이 되는 서버의 자원을 고갈시킬  <br> 목적으로 다수 공격자 or 시스템에서 대량의 데이터를 한 곳에 <br> 집중적으로 전송함 <br> Ping of Death (죽음의 핑) : Ping 명령을 전송할 때 패킷의 <br> 크기를 인터넷 프로토콜 허용범위 이상으로 전송하여 공격 <br> 대상의 네트워크를 마비시키는 서비스 거부 공격 <br> Smurfing : IP나 ICMP의 특성을 악용 엄청난 양의 데이터를 <br> 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 <br> 만드는 공격 방법. <br> SYN Flooding : TCP는 신뢰성 있는 전송을 위해 <br> 3-way-handshake를 거친 후 데이터를 전송하는데 SYN은 <br> 공격자가 가상의 클라이언트로 위장 3WH을 의도적으로 중단, <br> 서버가 대기상태에 놓여 정상 서비스를 못하게 하는 공격 방법 <br> TearDrop : Offset 값을 변경시켜 수신 측에서 패킷을 재조립 <br> 할 때 오류로 인한 과부하를 발생 시킴 <br> Land : 패킷을 전송할 때 송 수신 IP주소를 모두 공격대상 IP주소로 <br> 하여 공격대상에게 전송하는 것, 공격대상은 송신IP주소가 <br> 자신이기 때문에 자신에게 무한히 응답하게 되는 공격 <br> DDoS(분산 서비스 거부) : 여러 곳에 분산된 공격 지점에서 <br> 한 곳의 서버에 대해 분산 서비스 공격을 수행"
    }, {
      "num": 85,
      "subject": 4,
      "ask": "CMM(Capability Maturity Model) 모델의 레벨로 옳지 않은 것은?",
      "desc": "",
      "choice": {
        "1": "최적단계",
        "2": "관리단계",
        "3": "정의단계",
        "4": "계획단계"
      },
      "answer": 4,
      "comment": "CMM모델의 레벨 : 초기단계 / 관리단계 / 정의단계 / <br> 정량적 관리단계 / 최적화단계"
    }, {
      "num": 86,
      "subject": 3,
      "ask": "웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 속성·값의 쌍 형태로 표현하는 형식으로 자바스크립트(JavaScript)를 토대로 개발되어진 형식은?",
      "desc": "",
      "choice": {
        "1": "Python",
        "2": "XML",
        "3": "JSON",
        "4": "WEB SEVER"
      },
      "answer": 3,
      "comment": "JSON : 용량이 적은 데이터를 교환하기 위해 데이터의 객체를 <br> 속성,값의 쌍 형태로 표현하는 형식, 즉 데이터 객체를 <br> 전달하기 위해 사람이 읽을 수 있는 텍스트를 사용하는 것 <br> XML : 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 <br> 다목적 마크업 언어"
    }, {
      "num": 87,
      "subject": 2,
      "ask": "크래커가 침입하여 백도어를 만들어 놓거나, 설정 파일을 변경했을 때 분석하는 도구는?",
      "desc": "",
      "choice": {
        "1": "trace",
        "2": "tripwire",
        "3": "udpdump",
        "4": "cron"
      },
      "answer": 2,
      "comment": "Cron : 작업 예약 스케줄러 <br> - (초) / 분 / 일 / 시간 / 월 / 요일 / (년도) <br> <br> [시스템 침입탐지 및 무결성 도구] <br> Tripwire : 크래커가 침입하여 백도어를 만들어 놓거나 설정 <br> 파일을 변경했을 때 분석하는 도구 <br> - MD5, CRC-32, SHA 등의 알고리즘을 사용 <br> Aide : Tripwire를 대신할 수 있는 도구로 파일의 무결성을 <br> 검사하는데 사용 <br> sXid : MD5 체크섬을 사용하여 suid, sgid파일을 추적 루트 <br> 키트가 설치되어있는지 검사. Cron 작업형태로 수행. 자동 <br> 으로 차일을 추적하고 경고 <br> Claymore : 침입탐지 및 무결성 모니터링 도구로 크론테이블을 <br> 이용하여 주기적으로 파일시스템의 변조유무를 확인하고 <br> 변조되었을 경우 관리자에게 메일로 통보해 주는 기능 <br> Samhain : 시스템의 무결성을 점검하는 도구로 여러 시스템을 <br> 관리할 수 있는 수단을 제공한다. 모니터링 에이전트와 <br> 중앙 로그서버로 구성 <br> Slipwire : 파일시스템의 무결성을 검사하는 도구로 파일의 <br> SHA-1 hashes값을 비교하여 변경될 경우 사용자에게 경고하는 기능 <br> Fcheck : 유닉스 파일시스템의 변조유무를 점검하기 위한 <br> PERL script 도구로 syslog. console 등로 관리자에게 <br> 파일시스템 변화를 경보해 준다..tripwire와 비슷한 도구로 보다 <br> 설치 및 운영이 쉽다.."
    }, {
      "num": 88,
      "subject": 2,
      "ask": "소프트웨어 개발 프레임워크를 적용할 경우 기대효과로 거리가 먼 것은?",
      "desc": "",
      "choice": {
        "1": "품질보증",
        "2": "시스템 복잡도 증가",
        "3": "개발 용이성",
        "4": "변경 용이성"
      },
      "answer": 2,
      "comment": "프레임워크 : 특정 기능을 수행하기 위해 필요한 클래스 or <br> 인터페이스 등을 모아둔 집합체"
    }, {
      "num": 89,
      "subject": 2,
      "ask": "COCOMO model 중 기관 내부에서 개발된 중소 규모의 소프트웨어로 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용으로 5만 라인 이하의 소프트웨어를 개발하는 유형은?",
      "desc": "",
      "choice": {
        "1": "embeded",
        "2": "organic",
        "3": "semi-detached",
        "4": "semi-embeded"
      },
      "answer": 2,
      "comment": "유형별 COCOMO <br> Organic : 조직형 / 소규모 소프트웨어 일괄 자료 처리/ <br> 5만 라인 이하 <br> Semi-detached : 반분리형 / 트랜잭션 처리 시스템이나 <br> 운영체제, DB / 30만 라인 이하 <br> Embedded : 내장형 / 최대형 규모 트랜잭션 처리 시스템이나 <br> 운영체제 / 30만 라인 이상"
    }, {
      "num": 90,
      "subject": 1,
      "ask": "여러 개의 독립된 통신장치가 UWB(Ultra Wideband)기술 또는 블루투스 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술은?",
      "desc": "",
      "choice": {
        "1": "PICONET",
        "2": "SCRUM",
        "3": "NFC",
        "4": "WI-SUN"
      },
      "answer": 1,
      "comment": "네트워크 관리 신기술<br> IoT : 정보 통신 기술 기반 실세계와 가상세계의 사물을 <br> 인터넷으로 연결하여 서비스 제공하는 기술<br> M2M : 무선 통신을 이용한 기계와 기계사이의 통신 <br> 모바일 컴퓨팅 : 휴대형 기기로 이동하면서 자유로이 네트워크에 <br> 접속하여 업무를 처리할 수 있는 환경 <br> 클라우드 컴퓨팅 : 각종 컴퓨팅 자원을 중앙에 두고 인터넷 <br> 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 <br> 작업을 할 수 있는 환경을 의미 <br> 모바일 클라우드 컴퓨팅(MCC) : 클라우드 서비스 이용 <br> 소비자끼리 클라우드 컴퓨팅 인프라 구성하여 여러 정보와 <br> 자원을 공유하는 ICT 기술을 의미 <br> 인터클라우드 컴퓨팅 : 각기 다른 클라우드 서비스를 연동 및 <br> 컴퓨팅 자원의 동적 할당이 가능하도록 여러 클라우드 서비스 <br> 제공자들이 제공하는 클라우드 서비스 자원을 연결하는 기술. <br> 메시 네트워크 : 차세대 이동통신 공공안전 등 특수 목적을 <br> 위해 새로운 네트워크 기술로 대규모 디바이스의 네트워크 <br> 생성에 최적화 <br> 와이선 : 스마트 그리드와 같은 장거리 무선 통신을 필요로 <br> 하는 사물 인터넷 서비스를 위한 저전력 장거리 통신 기술 <br> NDN : 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 <br> 수행하는 기술 <br> NGN : 유선망 기반의 차세대 통신망 유선망뿐만 아니라 이동 <br> 사용자를 목표로 함 <br> SDN : 네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 <br> 각각의 소프트웨어들로 네트워킹을 가상화하여 제어하고 <br> 관리하는 네트워크 <br> NFC : 고주파를 이용한 근거리 무선 통신 기술 <br> UWB : 짧은 거리에서 많은 양의 디지털 데이터를 낮은 <br> 전력으로 전송하기 위한 무선 기술 <br> PICONET : 여러 개의 독립된 통신장치가 블루투스 기술이나 <br> UWB 통신 기술을 사용하여 통신망 형성 <br> WBAN : 웨어러블 형태의 센서나 기기를 무선으로 연결하는 <br> 개인 영역 네트워킹 기술 <br> GIS : 지리적인 자료를 수집 저장 분석 출력할 수 있는 컴퓨터 <br> 응용 시스템 <br> USN : 각종 센서로 수집한 정보를 무선으로 수집할 수 <br> 있도록 구성한 네트워크 <br> SON : 주변 상황에 맞추어 스스로 망을 구성하는 네트워크를 <br> 말한다. <br> ad-hoc network : 재난 현자와 같이 별도의 고정된 유선망을 <br> 구출할 수 없는 장소에 모바일 호스트만을 이용하여 구성한 <br> 네트워크 <br> 네트워크 슬라이딩 : 3GPP를 포함한 여러 글로벌 이동통신 <br> 표준화 단체가 선정한 5G의 핵심기술 <br> 저젼력 블루투스 기술 : 일반 블루투스와 동일한 주파수 대역을 <br> 사용하지만 연결되지않는 대기상태에서는 절전 모드를 <br> 유지하는 기술 <br> 지능형 초연결망 : 정부 주관 사업"
    }, {
      "num": 91,
      "subject": 1,
      "ask": "프로토타입을 지속적으로 발전시켜 최종 소프트웨어 개발까지 이르는 개발방법으로 위험관리가 중심인 소프트웨어 생명주기 모형은?",
      "desc": "",
      "choice": {
        "1": "나선형 모형",
        "2": "델파이 모형",
        "3": "폭포수 모형",
        "4": "기능점수 모형"
      },
      "answer": 1,
      "comment": "소프트웨어 생명 주기 모형 <br> 폭포수 : 선형 순차적 / 메뉴얼 작성 / 각 단계가 끝난 뒤 <br> 다음 단계로 넘어감 <br> <br> 타당성 검토 - 계획 - 요구분석 - 설계 - 구현 - 시험 - <br> 유지보수 <br> 프로토 : 원형 모형으로 실제 개발될 제품의 견본을 만들어 <br> 결과물을 예측하는 모형 <br> <br> 개발이 완료된 시점에서 오류가 발견되는 폭포수 모형 보완 <br> 요구수집 - 설계 - 구축 - 고객평가 - 조정 - 구현 <br> 나선형 : 점진적 모형 / 위험을 관리 및 최소화하는 것이 목적/ <br> 유지보수가 필요 없다 <br> 애자일 : 고객 중심적 모형 / 일정 주기를 반복하면서 <br> 개발과정 진행"
    }, {
      "num": 92,
      "subject": 1,
      "ask": "다음이 설명하는 용어로 옳은 것은?",
      "desc": "<img src='../assets/img/quizImg/202006_img92.png' alt='이미지'>",
      "choice": {
        "1": "하둡(Hadoop)",
        "2": "비컨(Beacon)",
        "3": "포스퀘어(Foursquare)",
        "4": "맴리스터(Memristor)"
      },
      "answer": 1,
      "comment": "[DB] <br> - 하둡 : 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼 <br> - 디지털 아카이빙 : 디지털 정보 자원을 장기적으로 보존하기 <br> 위한 작업 <br> - 타조 : 우리나라가 주도적으로 개발 중인 하둡 기반의 분산 <br> 데이터 웨어하우스 프로젝트 <br> - 데이터 다이어트 : 데이터를 삭제하는 것이 아닌 압축하고 <br> 중복된 정보를 배제하고 새로운 기분에 따라 나누어 저장하는 작업 <br> - 메타 데이터 : 일련의 데이터를 정의하고 설명해주는 데이터 <br> [네트워크] <br> - 비콘 : 블루투스 기반의 근거리 무선통신 장치 <br> - NFC : 고주파를 이용한 근거리 무선 통신 기술 <br> - NDN : 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 <br> 전송을 수행하는 기술 <br> - NGN : 유선망 기반의 차세대 통신망 <br> - 포스퀘어 : 위치 기반 소셜 네트워크 서비스 <br> [HW] <br> - 엠디스크 : 한 번의 기록만으로도 자료를 영구 보관할 <br> 수 있는 광 저장 장치 <br> - 맴리스터 : 메모리와 레지스터의 합성어로 전류의 방향과 <br> 양 등 기존의 경험을 모두 기억하는 소자. 차세대 메모리 <br> 기술 (ex: M.2)"
    }, {
      "num": 93,
      "subject": 1,
      "ask": "소인수 분해 문제를 이용한 공개키 암호화 기법에 널리 사용되는 암호 알고리즘 기법은?",
      "desc": "",
      "choice": {
        "1": "RSA",
        "2": "ECC",
        "3": "PKI",
        "4": "PEM"
      },
      "answer": 1,
      "comment": "1. RSA : MIT의 라이베스트,샤미르,애들먼에 의해 제안된 <br> 공개키 암호화 알고리즘 <br> 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어짐/ <br> 공개키와 비밀키 사용 <br> 2. ECC : 오류 정정 코드 메모리 (데이터 손상 감지 및 <br> 수정하는 기억장치) <br> 3. PKI : 공개키 기반 구조 <br> 4. PEM : SSL 인증서 종류 <br> <br> [블록 암호] - 대칭키 <br> DES : 구 미국 표준. 56비트 키를 사용 <br> AES : DES의 보안 취약점을 대체하기 위해 고안된 미국 <br> 표준 방식으로 현재 표준 대칭키 암호화 기법 <br> ARIA : SEED 이후로 나온 대한민국의 국가 암호 표준 <br> (AES와 동일) <br> <br> [공개키 암호] - 비대칭키 <br> RSA : 공개키 암호화 기법의 사실상 표준. 매우 큰 수의 <br> 소인수분해가 수학적으로 어렵다는 이론에 기반 <br> ECC : RSA의 키 길이가 너무 긴 결점을 보완하기 위해 <br> 타원곡선함수를 이용한 암호화 기법 <br> DSS(DSA) : 디지털 서명 표준 인증서 서비스"
    }, {
      "num": 94,
      "subject": 1,
      "ask": "LOC 기법에 의하여 예측된 총 라인수가 50000라인, 프로그래머의 월 평균 생산성이 200라인, 개발에 참여할 프로그래머가 10인 일 때, 개발 소요 기간은?",
      "desc": "",
      "choice": {
        "1": "25개월",
        "2": "50개월",
        "3": "200개월",
        "4": "2000개월"
      },
      "answer": 1,
      "comment": "개발소요기간= <br> (예측 총 라인수/월 평균생산성)/프로그래머 수X= <br> (50000/200)/10=25(개월)"
    }, {
      "num": 95,
      "subject": 1,
      "ask": "최대 홉수를 15로 제한한 라우팅 프로토콜은?",
      "desc": "",
      "choice": {
        "1": "RIP",
        "2": "OSPF",
        "3": "Static",
        "4": "EIGRP"
      },
      "answer": 1,
      "comment": "라우팅 프로토콜 <br> -RIP : 자율 시스템 내에서 사용 <br> 근거리 통신망 및 독립적 네트워크 내에서 라우팅 정보 관리 <br> 최대 홉수 카운트 15로 제한 16이상은 불가판정 <br> -OSPF : 가장 많이 사용되는 내부 라우티 프로토콜 <br> 효율을 위해 자율시스템을 여러 지역으로 나눔 <br> 홉수 카운트 대신 Cost사용 <br> -IGRP : Cisco System의 고유의 프로토콜 <br> hop 수를 기준으로 한 정보 전송 <br> 라우팅 경로 결정 시 회선의 전송능력 지연시간 사용률 <br> 신뢰도 바탕 독립적 네트워크 내에서만 사용 <br> -EIGRP : IGRP의 Metric 구성 값에 256을 곱하여 작동 <br> 프로토콜 종속 모듈 <br> 신뢰성 전송 프로토콜 (순차적 패킷 전달) <br> 낮은 대역폭 및 빠른 수렴 <br> 업데이트 확산 알고리즘 <br> -BGP : 라우터에 의해서 전체 경로 교환 <br> 루프 방지 <br> 179번 포트 이용한 TCP 서비스 사용 <br> 오류제어나 흐름제어 필요하지않음"
    }, {
      "num": 96,
      "subject": 1,
      "ask": "컴퓨터 사용자의 키보드 움직임을 탐지해 ID, 패스워드 등 개인의 중요한 정보를 몰래 빼가는 해킹 공격은?",
      "desc": "",
      "choice": {
        "1": "Key Logger Attack",
        "2": "Worm",
        "3": "Rollback",
        "4": "Zombie Worm"
      },
      "answer": 1,
      "comment": "1. 키보드 움직임 탐지 ID 패스워드 등 개인 중요 정보를  <br> 빼가는 해킹 공격 <br> 2. 연속적으로 자신을 복제하여 시스템 부하를 높임으로써  <br> 시스템을 다운시키는 바이러스 <br> 3. DCL언어 RollBack 말하는거 같음 해킹관련 용어라고 <br> 보기 어려움 <br> 4. 웜이 웜이지 좀비웜은 뭔지 모르겠음 말하고 싶은게 <br> 좀비PC인가 <br> <br> 해킹 공격 <br> -좀비PC : 악성코드에 감염되어 다른 프로그램 or 컴퓨터를 <br> 조종하도록 만들어진 컴퓨터 <br> -C&C서버 : 좀비PC에 명령을 내리고 악성코드를 제어하기 <br> 위한 용도의 서버 <br> -봇넷 : 악성 프로그램에 감염되어 악의적인 의도로 사용될 <br> 수 있는 네트워크 연결 형태 <br> -웜 : 연속적으로 자신을 복제하여 시스템 부하를 높임으로써 <br> 시스템을 다운시키는 바이러스 <br> -제로데이 공격 : 취약점 발견 시 취약점 존재를 알리기 전에 <br> 해당 취약점을 통해 이뤄지는 보안 공격 <br> -키로거 공격 : 컴퓨터 사용자의 움직임을 탐지 개인정보를 <br> 몰래 빼가는 공격 <br> -램섬웨어 : 내부 문서나 파일 등을 암호화해서 사용자가 <br> 열지 못하게 하는 프로그램 <br> -백도어 : 설계자가 서비스 기술자의 편의를 위해 보안을 <br> 제거하여 만들어놓은 비밀 통로 <br> -트로이 목마 : 정상적인 기능인 척하는 악성 프로그램"
    }, {
      "num": 97,
      "subject": 4,
      "ask": "테일러링(Tailoring) 개발 방법론의 내부 기준에 해당하지 않는 것은?",
      "desc": "",
      "choice": {
        "1": "납기/비용",
        "2": "기술환경",
        "3": "구성원 능력",
        "4": "국제표준 품질기준"
      },
      "answer": 4,
      "comment": "테일러링 (Tailoring) <br> 프로젝트 상황 특성에 맞게 정의된 소프트웨어 개발 방법론 <br> 절차, 사용기법 등을 수정 및 보완하는 작업 <br> 내부적 요건 : 목표환경 / 요구사항 / 프로젝트규모 / <br> 보유기술 / 외부적 요건 : 법적 제약사항 / 표준 품질 기준"
    }, {
      "num": 98,
      "subject": 1,
      "ask": "폭포수 모형의 특징으로 거리가 먼 것은",
      "desc": "",
      "choice": {
        "1": "개발 중 발생한 요구사항을 쉽게 반영할 수 있다.",
        "2": "순차적인 접근방법을 이용한다.",
        "3": "단계적 정의와 산출물이 명확하다.",
        "4": "모형의 적용 경험과 성공사례가 많다."
      },
      "answer": 1,
      "comment": "폭포수 : 선형 순차적 / 메뉴얼 작성 / 각 단계가 끝난 뒤 <br> 다음 단계로 넘어감 <br> 가장 오래됐고 가장 폭넓게 사용된 전통적인 모형<br> 타당성 검토 - 계획 - 요구분석 - 설계 - 구현 - 시험 -  <br> 유지보수 <br> <br> 1. 선형 순차적이라 앞단계 다 끝냈는데 갑자기 뭐 들고오면 <br> 빡쳐서 안한다고 생각하시면 됩니다. <br> 2. 선형 순차적 oo <br> 3. 단계가 끝나야 다음 단계로 넘어가기에 그 단계에서의 정의 <br> 및 산출물이 명확해야합니다. <br> 4. 오래된 모형으로서 적용 경험 및 성공사례가 많습니다."
    }, {
      "num": 99,
      "subject": 4,
      "ask": "문제",
      "desc": "<img src='../assets/img/quizImg/202006_img99.png' alt='이미지'>",
      "choice": {
        "1": "Smishing",
        "2": "C-brain",
        "3": "Trojan Horse",
        "4": "Ransomware"
      },
      "answer": 4,
      "comment": "1. SMS + 피싱 즉 SMS를 이용하는 피싱 사기 <br> 2. 브레인 : MS-DOS용 컴퓨터 바이러스 / 기억 매체의 <br> 시동 섹터를 감염 <br> 3. 트로이 목마 : 정상적인 기능인 척하는 악성 프로그램 <br> 4. 보기가 랜섬웨어에 관한 내용"
    }, {
      "num": 100,
      "subject": 4,
      "ask": "시스템 내의 정보는 오직 인가된 사용자만 수정할 수 있는 보안 요소는?",
      "desc": "",
      "choice": {
        "1": "기밀성",
        "2": "부인방지",
        "3": "가용성",
        "4": "무결성"
      },
      "answer": 4,
      "comment": "기밀성 - 열람 <br> 무결성 - 수정 <br> 가용성 - 사용"
    }]
  }]
}