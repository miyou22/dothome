<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        table tr td #span {
            color: #ff0000;
        }
    </style>
</head>
<body>
    <h2>학습 내용</h2>
    <ul> 
        <li>01. 프로그램 설계</li>
        <li>02. 코드 분석</li>
   </ul>   
   <h2>학습 목표</h2>
   <ul> 
       <li>01. 프로그래밍 개발 시 적절한 자료구조를 선택할 수 있다.</li>
       <li>02. 구조체를 사용하여 함수의 매개변수 전달을 구현할 수 있다.</li>
  </ul>  
  <H3 class="about">1. 프로그램 설계</H3>
  <TABLE border="1" color="blue">
    <TR>
        <td>
1)


1) 프로그램 기능 정의<br><br>
사진사진사진
2) 자료구조 정의
1. 자료구조 : 이름, 국어, 영어, 수학, 평균
struct sungjuk {
    char name[10]   
    int kor, eng, mat;
    double avg;
}
3)메뉴 구조
사진사진사진


2. 프로그래머가 작성한 소스파일이 컴파일 될수 있도록 준비함
3. 전처리기 문장은 '#'으로 시작 --> #include
#define -> 매크로를 정의
#include -> 헤더파일을 포함
#if, #else, #endif -> 조건에 따라 컴파일
#ifdef -> 매크로가 정의된 경우에 컴파일
#ifndef -> 매크로가 정의되지 않는 경우에 컴파일

2)매크로 상수
1. 정의: 코드의 분석을 용이 하게 함
2. 형식: #define 매크로명 값 --> #define MAX 100(매크로명 대문자로 만듬)
3. 소스파일에서 매크로 상수가 사용된 곳을 모두 찾아서 정의됨 문자열로 대치
-#define MAX 100
 average = sum /MAX <-- average = sum/100으로 처리됨
 printf("MAx = %d", MAX) <-- printf("MAx = %d", 100) 으로 처리됨
 이런경우 수정할 때 MAX값 뒤에 값만 수정하면 되어 매우 용이하다.

 3)매크로 함수
 1. 매크로 함수는 함수처럼 인자를 갖는 매크로
 2. 매크로 상수처럼 매크로 함수가 사용되는 곳에 문자열 대치를 통해서 코드를 확장함
 3. 형식: #define 매크로함수명(인자1, 인자2,...)대치할 내용 --> #define ADD(x,y) ((x)+(y));
 #define SQUARE(n) n*n
 int main(void)
 {
     int result = SQUARE(3); <---int result = 3*3으로 대치됨
 }
 3. 매크로 함수는 함수인 것처럼 보이지만 사실은 함수가 아님
 4. 컴파일 시에 인자의 데이터형 검사를 수행하지 않으며<br>
 인자를 매개변수로 전달하는 함수 호출과정이 수행되지 않음
 5. 매크로 함수 사용시 문자열 대치과정에서 잘못된 결과가 만들수 있음
 -#define SQUARE(n) n*n
 result = SQUARE(1+2); <--- result = 1+2 * 1+2로 처리됨
 6. 매크로 함수의 장점: 매크로 함수를 사용하면 프로그램의 실행속도가 빨라짐<br>
 ->매크로 함수를 사용할 때는 함수 호출이 일어나지 않으므로 함수 호출의 오버헤드를 줄일수 있음
 7. 매크로 함수의 단점
 - 매크로 함수를 많이 사용하는 프로그램은 프로그램의 크기가 커짐
 - 매크로 함수를 많이 사용하면 코드를 알아보기 어려워짐



2. 형식: 데이터형* 배열명[배열크기] --> int* arr1[5] (크기가 5인 int*을 선언함)<br>
- 포인터 배열의 각 원소로 변수를 저장함<br>
- 배열의 각 원소가 포인터형이므로, 원소가 가리키는 변수에 접근하려면<br>
배열의 원소 앞에 간접 참조 연산자 *를 사용해야 함<br><br>
3. 
2) 2차원 포인터 배열
1. 포인터 배열의 각 원소의 배열의 시작 주소를 저장
2. 형식: int x[3] = {1, 2, 3}; ---> arr[i][j]==*(arr[i]+j)
- arr[i]가 int 배열의 시작 주소로 초기화 되었을 때, arr[i]가 가리키는 배열의 원소에 접근하려면<br>
arr[i][j]를 사용함.


  <br>
  <H3 class="about1">2. 코드 분석</H3>
  <TABLE border="1" color="blue">
     <tr>
         <td>
            1) 헤더 파일<br>

            
            1. 특정 조건이 만족할 때만 코드를 컴파일함<br><br>
            2. 상황에 따라서 특정 코드를 컴파일하게 또는 컴파일하지 않게 만들수 있음<br>
            3. 이식성 있는 코드를 개발할 때 유용함
            4. 형식: #if 조건식 문장; #endif ---> #if WINVER >=0x0501 printf("윈도xp사용 \n")
            5. #if 사용시 마지막에는 #endif를 사용함 그리고 #else를 함께 사용할 수도 있음.
            6. #if의 조건식에는 매크로를 정수와 비교하는 관계 연산자가 주로 사용되고<br>
            산술연산자, 논리연산자 등이 사용될수 있음.
            7. #if의 조건식에서 매크로를 실수나 문자열과 비교할수 없음\
            8. #if, #endif에서는 컴파일할 문장이 여러개여도  {}로 묶어줄 필요가 없음
            9.#if안에 다른#if를 중첩해서 사용할수 있으며, 각각의 #if마다 #endif가 하나씩 짝을 이루어야 함
            
            2)#ifdef
            1. "if defined"라는 의미 => 만약에 정의에되어 있다면 이라는 뜻
            2. #ifdef는 특정 매크로의 정의 여부에 따라 #ifdef와 #endif사이의 문장을 컴파일 할지 결정
            3. #ifdef 매크로명 문장; #endif --> #ifdef DEBUG printf("n=%d", n); #endif

            3)#ifndef
            1. "if not defined"라는 의미 => 만약 정의되어 있지 않다면 이라는 뜻
            2. ifnded 다음의 매크로가 정의되지 않은 경우에만  #ifndef와 #endif 사이의 문장이 컴파일
            3. #ifndef NAME_SIZE #define NAME_SIZE20 #endif =>NAME_SIZE가 정의 되어있지 않다면 정의하시오
            3. 형식<br>
            student s1;
            student s2;
            student s3;
            student* std[3] = { %s1, %s2, %s3};
            printf("%s", std[i] -> name);

            2) 2차원 배열 포인터 처리
            1. 행 단위 포인터 변수
            2. 형식: 데이터형(*포인터명)[배열크기]; --> int(*p1)[5];
            3. 배열에 대한 포인터를 &arr[0]으로 초기화 하는 대신, 간단하게 arr로 초기화 할수 있음
            int(*p)[5]=arr; <--- arr는 &arr[0]과 같은 의미임
            4. 배열에 대한 포인터 p로 이차원 배열의 원소에 접근하려면 p가 마치 이차원 배열명인것처럼<br>
            2개의 인덱스를 사용하면 됨
            int i,j;
            for(i=0; i<3; i++)
            {
                for(i=0; j<5; j++)
                    printf("%d", p[i][j]); <--- p[i][j]는 이차원 배열의 원소 arr[i][j]를 의미함
                printf("\n")
            }

            4. 초기화는 기억공간 할당 시 한번만 초기화 됨<br>
            5. 정적 지역 변수는 전역 변수처럼 프로그램이 시작할 때 메모리에 할당되고 프로그램이 종료할 때 해체됨
            6. 전역 변수와는 달리 정적 지역 변수는 선언된 함수 안에서만 사용
            7. 정적 지역변수는 함수가 리턴하더라도 해제되지 않고 남아있다가 그 다음 함수 호출시 그대로 다시 허용

            2) 정적 전역 변수
            1. 정적 전역 변수는 정적 전역 변수가 선언된 소스 파일에서만 사용
            2. 정적 전역변수는 전역 변수를 다른 소스파일에서 접근하지 못하도록 제한

            3) 스토리지 클래스 비교
            사진사진사진
            void(int <font color="red">*a</font>)<br>
            {<br>
                ...<br>
            }<br>
            int main()<br>
            {<br>
                int std[30];<br>
                ...<br>
                sub(<font color="red">std</font>);<br>
            }<br><br>
            2)구조체 전달<br>
            1. 구조체 전달 시 포인터 전달의 장점<br>
            -주소 보관을 위해 4바이터의 크기만 사용
            <table border='1'> 
                <tr>
                    <td>
                        s구조체일시 수정전<br><br>
                        struct salary { <br>
                            int pay; <br>
                            int time; <br>
                        } <br>
                    </td>
                    <td>
                        구조체일시 수정후<br><br>
                        struct salary { <br>
                            double pay;  <br>
                            double time; <br>
                        }
                    </td>
                </tr>
                <tr> 
                    <td>
                        typedef 일시 수정전<br><br>
                        typedef int size; <br>
                        struct salary { <br>
                            size pay; <br>
                            size time; 
                        }
                    </td>
                    <td>
                        typedef 일시 수정후<br><br>
                        typedef double size; <br>
                        struct salary { <br>
                            size pay; <br>
                            size time; <br>
                    </td>
                </tr>
            </table><br>
            2)typedef<br>
            1. 데이터 타입의 이름을 새로운 이름으로 재정의 <br><br>
            2. 사용시 코딩의 편리성 증대 <br><br>
            3. 프로그램의 시스템 간 호환성 향상 <br><br>
            
            4. 형식: typedef 기존 데이터형 새이름; -> typedef unsigned int unit;<br><br>
            5. 구조체에서 유용하게 사용<br>
            
         </td>
     </tr>
  </TABLE>

</body>
</html>